---
editor: 
  markdown: 
    wrap: sentence
---

```{r}
#| include: false

source("_common.R")
```

# 문자열 {#r-string}

텍스트 데이터는 프로그래밍에서 가장 흔히 다루는 데이터 유형이다. 사용자 이름, 이메일 주소, 로그 파일, 웹페이지 내용, CSV 파일의 각 셀 등 모든 곳에 문자열이 존재한다. 데이터 분석에서도 텍스트 전처리, 패턴 매칭, 정보 추출 등 문자열 조작은 핵심 기술이다.

문자열을 다루는 기본 개념을 이해하면, AI에게 텍스트 처리 작업을 명세할 때도 정확한 요구사항을 전달할 수 있다. "문자열의 3번째부터 7번째 문자를 추출해줘"라고 말하려면, 먼저 인덱싱과 슬라이싱이 무엇인지 알아야 한다.

## 문자열은 시퀀스다 {#r-string-sequence}
\index{시퀀스}
\index{문자}
\index{꺾쇠 연산자}
\index{연산자!꺾쇠}


문자열은 여러 문자들의 시퀀스(sequence)다.
꺾쇠 연산자로 한 번에 하나씩 문자에 접근한다.
`substr()` 함수를 사용해서 바로 특정 문자를 추출할 수도 있지만, `strsplit()` 함수로 문자열을 문자의 벡터로 다루는 방법도 있다.

::: panel-tabset
### R

```{webr-r}
#| label: r-string-seq
fruit <- 'banana'
fruit_letter <- strsplit(fruit, "")[[1]]

letter <- fruit_letter[1]
```

### 파이썬

```{pyodide-python}
#| label: r-string-seq
fruit = 'banana'
letter = fruit[1]
```
:::

두 번째 문장은 변수 `fruit_letter`에서 1번 위치 문자를 추출하여 변수 `letter`에 대입한다.
꺾쇠 표현식을 인덱스(index)라고 부른다.
인덱스는 순서(sequence)에서 사용자가 어떤 문자를 원하는지 표시한다.

하지만, 여러분이 기대한 것은 출력됨이 확인된다.

::: panel-tabset
### R

```{webr-r}
#| label: r-string-seq-output
letter
```

### 파이썬

```{pyodide-python}
#| label: py-string-seq-output
letter
```
:::

파이썬 사용자에게 'banana'의 첫 문자는 a가 아니라 b다.
하지만, 파이썬 인덱스는 문자열 처음부터 오프셋(offset)[^06-string-1]이다.
첫 글자 오프셋은 0이다.

[^06-string-1]: 컴퓨터에서 어떤 주소로부터 간격을 두고 떨어진 주소와의 거리를 말한다.
    기억 장치가 페이지 혹은 세그먼트 단위로 나누어져 있을 때 하나의 시작 주소로부터 오프셋만큼 떨어진 위치를 나타낸다.
    네이버 지식백과(IT용어사전, 한국정보통신기술협회)

하지만, R은 사람 친화적이기 때문에 b가 'banana'의 첫 번째 문자가 되고 a가 두 번째, n이 세 번째 문자가 된다.
\index{인덱스!1 에서 시작}
\index{1, 인덱스 시작점}


![바나나 문자열](images/string-banana.png){#fig-banana-string fig-align="center" width="251"}

인덱스로 문자와 연산자를 포함하는 어떤 표현식도 사용 가능지만, 인덱스 값은 정수일 필요는 없다.
정수가 아닌 경우 다음과 같은 결과를 얻게 된다.
문제는 R에서 `1.5`를 내려서 `1`로 처리한다는 점이다.
경우에 따라서는 반올림으로 판단해서 `2`가 될 수도 있어 오해의 소지가 있기 때문에 무조건 정수로 표현한다.
\index{인덱스}
\index{예외!자료형 오류}
\index{자료형 오류}



::: panel-tabset
### R

```{webr-r}
#| label: r-string-integer
fruit_letter[1.5]
```

### 파이썬

```{pyodide-python}
#| label: py-string-integer
letter = fruit[1.5]
#> TypeError: string indices must be integers
```
:::

## `length()` 함수 사용 문자열 길이 구하기 {#r-string-length}

`length()` 함수는 문자열의 문자 갯수를 반환하는 내장함수다.
\index{length 함수}
\index{함수!length}

::: panel-tabset
### R

```{webr-r}
#| label: r-string-length
fruit <- 'banana'
fruit_letter <- strsplit(fruit, "")[[1]]

length(fruit_letter)
```

### 파이썬

```{pyodide-python}
#| label: py-string-length
fruit = 'banana'
len(fruit)
#> 6
```
:::

문자열의 가장 마지막 문자를 얻기 위해서, 아래와 같이 시도하고 싶을 것이다.
\index{예외!인덱스 오류}
\index{인덱스 오류}

::: panel-tabset
### R

```{webr-r}
#| label: r-string-last
len <- length(fruit_letter)
fruit_letter[len]
```

### 파이썬

```{pyodide-python}
#| label: py-string-last
length = len(fruit)
last = fruit[length]
#> IndexError: string index out of range
```
:::

파이썬에서는 인덱스 오류(IndexError)가 발생하는데 이유는 'banana'에 6번 인덱스 문자가 없기 때문이다.
0에서부터 시작했기 때문에 6개 문자는 0에서부터 5까지 번호가 매겨졌다.
마지막 문자를 얻기 위해서 length에서 1을 빼야 한다.
`fruit[-1]`은 마지막 문자를, `fruit[-2]`는 끝에서 두 번째 문자를 가리킨다.
하지만, R에서는 사람이 생각하는 방식대로 마지막 문자를 얻는다.
\index{인덱스!음수}
\index{음수 인덱스}


## 루프를 사용한 문자열 순회 {#r-string-traversal}
\index{순회}
\index{루프!순회}
\index{for 문}
\index{루프!for}
\index{문장!for}

연산의 많은 경우에 문자열을 한 번에 한 문자씩 처리한다.
종종 처음에서 시작해서, 차례로 각 문자를 선택하고, 선택된 문자에 임의 연산을 수행하고, 끝까지 계속한다.
이런 처리 패턴을 **순회(traversal)**라고 한다.
순회를 작성하는 한 방법이 `while` 루프다.

::: panel-tabset
### R

```{webr-r}
#| label: r-string-traversal
index <- 1

while(index <= length(fruit_letter)){
  letter <- fruit_letter[index]
  print(letter)
  index <- index + 1
}
```

### 파이썬

```{pyodide-python}
#| label: py-string-traversal
index = 0

while index < len(fruit):
    letter = fruit[index]
    print(letter)
    index = index + 1
```
:::

`while` 루프가 문자열을 순회하여 문자열을 한 줄에 한 글자씩 화면에 출력한다.
루프 조건이 `index <= length(fruit_letter)`이어서, `index`가 문자열 길이와 같을 때, 조건은 거짓이 되고, 루프의 몸통 부문은 실행되지 않는다.
R이 접근한 마지막 `length(fruit_letter)` 인덱스 문자로, 문자열의 마지막 문자다.

::: callout-warning
### 연습문제

문자열의 마지막 문자에서 시작해서, 문자열 처음으로 역진행하면서 한 줄에 한 자씩 화면에 출력하는 `while` 루프를 작성하세요.
:::

순회를 작성하는 또 다른 방법은 `for` 루프다.

::: panel-tabset
### R

```{webr-r}
#| label: r-string-banana-for
for(char in fruit_letter) {
  print(char)
}
```

### 파이썬

```{pyodide-python}
#| label: py-string-banana-for}
for char in fruit:
    print(char)
```
:::

루프를 매번 반복할 때, 문자열 다음 문자가 변수 `char`에 대입된다.
루프는 더 이상 남겨진 문자가 없을 때까지 계속 실행된다.

## 문자열 슬라이스 {#r-string-slice}
\index{슬라이스 연산자}
\index{연산자!슬라이스}
\index{인덱스!슬라이스}
\index{문자열!슬라이스}
\index{슬라이스!문자열}

문자열의 일부분을 **슬라이스(slice)**라고 한다.
문자열 슬라이스를 선택하는 것은 문자를 선택하는 것과 유사하다.

::: panel-tabset
### R

```{webr-r}
#| label: r-string-slice}
s <- strsplit('Monty Python', "")[[1]]
paste(s[1:5], collapse="")
#> [1] "Monty"
paste(s[7:12], collapse="")
#> [1] "Python"
```

### 파이썬

```{pyodide-python}
#| label: py-string-slice}
s = 'Monty Python'
print(s[0:5])
#> [1] "Monty"
print(s[6:13])
#> [1] "Python"
```
:::

`[n:m]` 연산자는 `n`번째 문자부터 `m`번째 문자까지의 문자열 부분을 반환한다.

파이썬에서 `fruit[:3]`와 같이 콜론 앞 첫 인덱스를 생략하면, 문자열 슬라이스는 문자열 처음부터 시작한다.
파이썬에서 `fruit[3:]`와 같이 두 번째 인덱스를 생략하면, 문자열 슬라이스는 문자열 끝까지 간다.

이와 동일한 역할을 수행하는 방법은 `head(fruit_letter, 3)`, `tail(fruit_letter, 3)`와 같이 `head()`, `tail()` 함수를 활용한다.

::: panel-tabset
### R

```{webr-r}
#| label: r-string-slice-banana
fruit <- 'banana'
fruit_letter <- strsplit(fruit, "")[[1]]

paste(head(fruit_letter, 3), collapse="")
paste(tail(fruit_letter, 3), collapse="")
```

### 파이썬

```{pyodide-python}
#| label: py-string-slice-banana
fruit = 'banana'

fruit[:3]
fruit[3:]
```
:::

만약 첫 번째 인덱스가 두 번째보다 크거나 같은 경우 파이썬에서는 결과가 인용부호로 표현되는 빈 문자열(empty string)이 된다.
하지만, R에서는 해당 인덱스에 해당되는 문자가 추출된다.
\index{인용 부호}

::: panel-tabset
### R

```{webr-r}
#| label: r-string-slice-empty
fruit_letter[3:3]
```

### 파이썬

```{pyodide-python}
#| label: py-string-slice-empty
fruit = 'banana'
fruit[3:3]
#> ''
```
:::

빈 문자열은 어떤 문자도 포함하지 않아서 길이가 0이지만, 이것을 제외하고 다른 문자열과 동일하다.
\index{복사!슬라이스}
\index{슬라이스!복사}


::: callout-warning
### 연습문제 (파이썬)

`fruit`이 문자열로 주어졌을 때, `fruit[:]`의 의미는 무엇인가요?

::: {.content-visible when-format="revealjs"}
`fruit[:]`는 파이썬에서 문자열 슬라이싱(slicing) 표현식의 한 형태로 `fruit`라는 문자열의 시작부터 끝까지 전체 문자열을 선택하는 것을 의미한다.

예를 들어, `fruit = 'banana'`라면, `fruit[:]`는 `'banana'`를 결과로 반환한다.
종종 문자열을 복사할 때 사용된다.
:::
:::

## 문자열은 불변이다 (파이썬)
\index{가변성}
\index{불변성}
\index{문자열!불변성}


문자열 내부에 있는 문자를 변경하려고 대입문 왼쪽편에 `[]` 연산자를 사용하고 싶은 유혹이 있을 것이다.
예를 들어 다음과 같다.
\index{자료형 오류}
\index{예외!자료형 오류}


::: panel-tabset
### R

```{webr-r}
#| label: r-string-immutable
greeting <- strsplit('Hello, world!', "")[[1]]
greeting[1] <- 'J'

paste0(greeting, collapse="")
```

### 파이썬

```{pyodide-python}
#| label: py-string-immutable
greeting = 'Hello, world!'
greeting[0] = 'J'
#> TypeError: 'str' object does not support item assignment

greeting = 'Hello, world!'
new_greeting = 'J' + greeting[1:]
print(new_greeting)
#> Jello, world!
```
:::

파이썬에서 "TypeError: 'str' object does not support item assignment" 오류가 발생하는데 파이썬 문자열이 불변(immutable)하기 때문이다.
즉, 파이썬에서 문자열의 특정 문자를 직접 변경하려고 할 때 이 오류가 발생한다.
반면에, R에서는 문자열 자체가 불변 객체로 취급되지 않기 때문에 `strsplit` 함수를 사용하여 문자열을 문자의 벡터로 변환하면, 벡터의 각 요소는 별도의 문자열로 취급되어 개별적으로 변경할 수 있다.
R은 파이썬과 달리 불변 문자열에 대한 제약이 없기 때문에 오류를 발생시키지않는다.

파이썬에서 "객체(object)"는 문자열이고, 대입하고자 하는 문자는 "항목(item)"이다.
지금으로서 객체는 값과 동일하지만, 나중에 객체 정의를 좀 더 상세화할 것이다.
항목은 순서 값 중의 하나다.
최선의 방법은 원래 문자열을 변형한 새로운 문자열을 생성하는 것이다.
\index{객체}
\index{항목 대입}
\index{대입!항목}
\index{불변성}

새로운 첫 문자에 `greeting` 문자열 슬라이스를 연결한다.
원래 문자열에는 어떤 영향도 주지 않는 새로운 문자열이 생성되었다.
\index{접합}

## 루프 사용 문자 계수하기 {#r-string-count}
\index{계수기}
\index{계수와 루프 돌기}
\index{루프 돌기와 계수}
\index{루프 돌기!문자열}

다음 프로그램은 문자열에 문자 `a`가 나타나는 횟수를 계수(counting)한다.

::: panel-tabset
### R

```{webr-r}
#| label:  r-string-a-count
word <- strsplit('banana', "")[[1]]
count <- 0
for(letter in word) {
  if(letter == 'a'){
    count <- count + 1
  }
}

count
```

### 파이썬

```{pyodide-python}
#| label: py-string-a-count
word = 'banana'
count = 0

for letter in word:
    if letter == 'a':
        count = count + 1

print(count)
```
:::

상기 프로그램은 **계수기(counter)**라고 부르는 또 다른 연산 패턴을 보여준다.
변수 count는 0으로 초기화되고, 매번 `a`를 찾을 때마다 증가한다.
루프를 빠져나갔을 때, `count`는 결과 값 즉, a가 나타난 총 횟수를 담고 있다.

::: callout-warning
### 연습문제

문자열과 문자를 인자(argument)로 받도록 상기 코드를 `count`라는 함수로 **캡슐화(encapsulation)**하고 일반화하세요.
\index{캡슐화}
:::

## `%in%` 연산자 {#r-string-in-operator}
\index{%in% 연산자}
\index{연산자!%in%}
\index{부울 연산자}
\index{연산자!부울}


연산자 `in`은 부울 연산자로 두 개의 문자열을 받아, 첫 번째 문자열이 두 번째 문자열의 일부이면 참(TRUE)을 반환한다.

::: panel-tabset
### R

```{webr-r}
#| label: r-string-in-op
'a' %in% strsplit('banana', "")[[1]]
'seed' %in% strsplit('banana', "")[[1]]
```

### 파이썬

```{pyodide-python}
#| label: py-string-in-op
'a' in 'banana'
#> True
'seed' in 'banana'
#> False
```
:::

## 문자열 비교 {#r-string-comparison-operator}
\index{문자열!비교}
\index{비교!문자열}


비교 연산자도 문자열에서 동작한다.
두 문자열이 같은지를 살펴보자.

::: panel-tabset
### R

```{webr-r}
#| label: r-string-comparison
word <- 'banana'

if(word == 'banana') {
  print('All right, bananas.')
}
```

### 파이썬

```{pyodide-python}
#| label: py-string-comparison
word = 'banana'

if word == 'banana':
    print('All right, bananas.')
```
:::

다른 비교 연산자는 단어를 알파벳 순서로 정렬하는 데 유용하다.

::: panel-tabset
### R

```{webr-r}
#| label: r-string-pineapple
word <- 'Pineapple'

if(word < 'banana') {
  message('Your word ',  word, ' comes before banana.')
} else if (word > 'banana') {
  message('Your word ', word, ' comes after banana.')
} else {
  message('All right, bananas.')
}
```

### 파이썬

```{pyodide-python}
#| label: py-string-pineapple
word = 'Pineapple'

if word < 'banana':
    print('Your word, ' + word + ', comes before banana.')
elif word > 'banana':
    print('Your word, ' + word + ', comes after banana.')
else:
    print('All right, bananas.')
```
:::

R과 파이썬 같은 프로그래밍 언어는 사람과 동일한 방식으로 대문자와 소문자를 다루지 않는다.
모든 대문자는 소문자 앞에 온다.
프로그래밍 언어에서 대문자와 소문자를 다루는 방식은 ASCII 코드 값을 기반으로 한다.
ASCII 코드에서 대문자(A-Z)는 65부터 90까지의 값을, 소문자(a-z)는 97부터 122까지의 값을 갖기 때문에 대문자가 숫자적으로 소문자보다 먼저 나오기 때문에 문자열을 정렬하거나 비교할 때, 대문자가 소문자 앞에 위치하게 된다.

``` bash
Your word, Pineapple, comes before banana.
```

이러한 문제를 다루는 일반적인 방식은 비교 연산을 수행하기 전에 문자열을 표준 포맷으로 예를 들어 모두 소문자로 변환하는 것이다.
경우에 따라서 "Pineapple"로 무장한 사람들로부터 여러분을 보호해야 하는 것도 명심한다.

## 문자열 함수 {#r-string-method}

R은 객체지향언어 특성을 갖고 있지만 함수형 프로그래밍 언어 특성도 갖고 있다.
문자열을 R 객체(objects)로 객체를 데이터(실제 문자열 자체)와 메서드(methods)를 담고 있는 것으로 바라볼 수도 있다.
메서드는 객체에 내장되고 어떤 객체의 인스턴스(instance)에도 사용되는 사실상 함수다.
\index{메서드}
\index{문자열!메서드}
\index{점 표기법}
\index{괄호!빈}
\index{호출}

::: callout-note
### 파이썬 `dir` 함수

객체에 대해 이용 가능한 메서드를 보여주는 `dir` 함수가 파이썬에 있다.
`type` 함수는 객체의 자료형(type)을 보여주고, `dir`은 객체에 사용될 수 있는 메서드를 보여준다.

```{pyodide-python}
#| label: py-string-dir
#| 
stuff = 'Hello world'
type(stuff)
#> <type 'str'>
methods = [method for method in dir(stuff) if not method.startswith('__') and not method.endswith('__')]
methods
#> ['capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isascii', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'removeprefix', 'removesuffix', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill']
```

`dir` 함수가 메서드 목록을 보여주고, 메서드에 대한 간단한 문서 정보는 `help`를 사용할 수 있지만, 
문자열 메서드에 대한 좀 더 좋은 문서 정보는 <https://docs.python.org/3/library/string.html>에서 찾을 수 있다.

인자를 받고 값을 반환한다는 점에서 메서드(method)를 호출하는 것은 함수를 호출하는 것과 유사하지만, 구문은 다르다.
구분자로 점을 사용해서 변수명에 메서드명을 붙여 메서드를 호출한다.

예를 들어, `upper` 메서드는 문자열을 받아 모두 대문자로 변환된 새로운 문자열을 반환한다.
함수 구문 `upper(word)` 대신에, `word.upper()` 메서드 구문을 사용한다.
:::

하지만, 함수형 프로그래밍 패러다임으로 문자열을 객체로 두고 함수를 적용시켜 다양한 작업을 하는 것이 일반적이다.
`tidyverse` 패키지를 설치하게 되면 `stringr` 패키지가 구성요소로 포함되어 있다.
`str_`로 시작되는 다양한 함수가 지원된다.
\index{계수 메서드}
\index{메서드!계수}

예를 들어, `stringr` 패키지 `str_to_upper()` 함수는 문자열을 받아 모두 대문자로 변환된 새로운 문자열을 반환한다.

::: panel-tabset
### R

```{webr-r}
#| label: r-string-upper
library(stringr)

word <- 'banana'
new_word <- stringr::str_to_upper(word)
new_word
#> [1] "BANANA"
```

### 파이썬

```{pyodide-python}
#| label: r-string-upper
word = 'banana'
new_word = word.upper()
print(new_word)
#> BANANA
```
:::

동일한 작업을 함수형 패러다임으로 `str_to_upper(word)`와 같이 표현하는 데 반해, 객체지향으로 구현하면 파이썬 같은 경우 `word.upper()` 메서드 구문이 사용된다.

예를 들어, 문자열 안에 문자열의 위치를 찾는 `str_locate()`, `str_locate_all()`이라는 문자열 함수가 있다.
`str_locate()`는 매칭되는 첫 번째만 반환하는 반면에 `str_locate_all()`은 매칭되는 전부를 반환하는 차이가 있다.

::: panel-tabset
### R

```{webr-r}
#| label: r-string-locate
str_locate(word, 'a')
#>      start end
#> [1,]     2   2
```

### 파이썬

```{pyodide-python}
#| label: py-string-locate
word = 'banana'
index = word.find('a')
print(index)
#> 1
```
:::

상기 예제에서, word 문자열에 `str_locate_all()` 함수를 호출하여 매개 변수로 찾고자 하는 문자를 넘긴다.

`str_locate_all()` 함수로 문자뿐만 아니라 부속 문자열(substring)도 찾을 수 있다.

::: panel-tabset
### R

```{webr-r}
#| label: r-string-locate-substring
str_locate_all(word, 'na')[[1]]
#>      start end
#> [1,]     3   4
#> [2,]     5   6
```

### 파이썬

```{pyodide-python}
#| label: py-string-locate-substring
word.find('na')
#> 2
word.find('na', 3)
#> 4
```
:::

한 가지 자주 있는 작업은 `str_trim()` 함수를 사용해서 문자열 시작과 끝의 공백(공백 여러 개, 탭, 새줄)을 제거하는 것이다.

::: panel-tabset
### R

```{webr-r}
#| label: r-string-strip
line <- '     Here we go '
str_trim(line)
#> [1] "Here we go"
```

### 파이썬

```{pyodide-python}
#| label: py-string-strip
line = '     Here we go '
line.strip()
#> 'Here we go'
```
:::

`str_detect()` 함수와 나중에 다룰 정규표현식을 섞어 표현하게 되면 참, 거짓 같은 부울 값(boolean value)을 반환한다.
`'^Please'`에서 `^`은 문자열 시작을 지정한다.

::: panel-tabset
### R

```{webr-r}
#| label: r-string-startwith
line <- '좋은 하루되세요!'
str_detect(line, '^좋은')
#> [1] TRUE
```

### 파이썬

```{pyodide-python}
#| label: py-string-startwith
line = '좋은 하루되세요!'
line.startswith('좋은')
#> True
line.startswith('조은')
#> False
```
:::

대소문자를 구별하는 것을 요구하기 때문에 `str_to_lower()` 함수를 사용해서 검증을 수행하기 전에, 한 줄을 입력받아 모두 소문자로 변환하는 것이 필요하다.

::: panel-tabset
### R

```{webr-r}
#| label: r-string-startwith-to-lower
line <- 'Please have a nice day'
str_detect(line, '^p')

str_to_lower(line)

str_detect(str_to_lower(line), '^p')
```

### 파이썬

```{pyodide-python}
#| label: py-string-startwith-to-lower
line = 'Please have a nice day'
line.startswith('p')
#> False
line.lower()
#> 'please have a nice day'
line.lower().startswith('p')
#> True
```
:::

마지막 예제에서 문자열이 문자 "p"로 시작하는지를 검증하기 위해서, `str_to_lower()` 함수를 호출하고 나서 바로 `str_detect()` 함수를 사용한다.
주의 깊게 순서만 다룬다면, 한 줄에 다수 함수를 괄호에 넣어 호출할 수 있다.

::: callout-warning
### 연습문제

앞선 예제와 유사한 함수인 `str_count()`로 불리는 문자열 메서드가 `stringr` 패키지 내부에 있다.
`? str_count()` 도움말로 `str_count()` 함수에 대한 문서를 읽고, 문자열 'banana'의 문자가 몇 개인지 계수하는 메서드 호출 프로그램을 작성하세요.
:::

## 문자열 파싱 {#r-string-parsing}

종종, 문자열을 들여다보고 특정 부속 문자열(substring)을 찾고 싶다.
예를 들어, 아래와 같은 형식으로 작성된 일련의 라인이 주어졌다고 가정하면,

> `From stephen.marquard@`**uct.ac.za**`Sat Jan  5 09:14:16 2008`

각 라인마다 뒤쪽 전자우편 주소(즉, uct.ac.za)만 뽑아내고 싶을 것이다.
`str_locate()` 함수와 문자열 슬라이싱(string sliceing)을 사용해서 작업을 수행할 수 있다.

우선, 문자열에서 골뱅이(`@`, at-sign) 기호의 위치를 찾는다.
그리고, 골뱅이 기호 뒤 첫 공백 위치를 찾는다.
그리고 나서, 찾고자 하는 부속 문자열을 뽑아내기 위해서 문자열 슬라이싱을 사용한다.

::: panel-tabset
### R

```{webr-r}
#| label: r-string-email-parsing
data <- 'From stephen.marquard@uct.ac.za Sat Jan 5 09:14:16 2008'
atpos <- str_locate(data, '@')
atpos[1,1]
#> start 
#>    5 
sppos <- str_locate_all(data, ' ')[[1]]
sppos
#>      start end
#> [1,]     5   5
#> [2,]    32  32
#> [3,]    36  36
#> [4,]    40  40
#> [5,]    42  42
#> [6,]    51  51
str_sub(data, start = atpos[1,1] + 1, end = sppos[2,2] - 1)
#> [1] "uct.ac.za"

```

### 파이썬

```{pyodide-python}
#| label: py-string-email-parsing
data = 'From stephen.marquard@uct.ac.za Sat Jan 5 09:14:16 2008'
atpos = data.find('@')
print(atpos)
#> 21
sppos = data.find(' ',atpos)
print(sppos)
#> 31
host = data[atpos+1:sppos]
print(host)
#> uct.ac.za
```
:::

`str_locate()` 함수를 사용해서 찾고자 하는 문자열의 시작 위치를 명세한다.
문자열 슬라이싱(slicing)할 때, 골뱅이 기호 뒤부터 빈 공백을 포함하지 않는 위치까지 문자열을 뽑아낸다.

## 서식 연산자 {#r-string-format}
\index{서식 연산자}
\index{연산자!서식}

**서식 연산자(format operator)** Base R의 `sprintf()` 함수에 C언어 스타일로 `%`를 사용하기도 하지만 
[glue: Interpreted String Literals](https://cran.r-project.org/web/packages/glue/index.html) 패키지도 최근에 많이 사용된다.
`glue` 패키지 `{}`는 문자열 일부를 변수에 저장된 값으로 바꿔 문자열을 구성한다.
정수에 서식 연산자가 적용될 때, {}는 나머지 연산자가 된다.
하지만 첫 피연산자가 문자열이면, {}은 서식 연산자가 된다.
동일한 기능을 `stringr` 패키지 `str_glue()` 함수로 수행할 수 있다.
\index{서식 문자열}

첫 피연산자는 서식 문자열(format string)로 두 번째 피연산자가 어떤 형식으로 표현되는지를 명세하는 하나 혹은 그 이상의 서식 순서(format sequence)를 담고 있다.
결과값은 문자열이다.
\index{서식 순서}

예를 들어, 형식 순서 '%d'의 의미는 두 번째 피연산자가 정수 형식으로 표현됨을 뜻한다.
(d는 "decimal"을 나타낸다.)

::: panel-tabset
### R

```{webr-r}
#| label: r-string-format
camels <- 42
sprintf('%d', camels)
#> [1] "42"
str_glue("{camels}")
#> 42
```

### 파이썬

```{pyodide-python}
#| label: py-string-format
camels = 42
'%d' % camels
#> '42'
```
:::

결과는 문자열 '42'로 정수 42와 혼동하면 안 된다.

서식 순서는 문자열 어디에도 나타날 수 있어서 문장 중간에 값을 임베드(embed)할 수 있다.

::: panel-tabset
### R

```{webr-r}
#| label: r-string-format-camels
camels <- 42
sprintf('I have spotted %d camels.', camels)
#> [1] "I have spotted 42 camels."
str_glue('I have spotted {camels} camels.')
#> I have spotted 42 camels.
```

### 파이썬

```{pyodide-python}
#| label: py-string-format-camels
camels = 42
'I have spotted %d camels.' % camels
#> 'I have spotted 42 camels.'
```
:::

만약 문자열 서식 순서가 하나 이상이라면, 두 번째 인자는 튜플(tuple)이 된다.
서식 순서 각각은 순서대로 튜플 요소와 매칭된다.

다음 예제는 정수 형식을 표현하기 위해서 '%d', 부동 소수점 형식을 표현하기 위해서 '%g', 문자열 형식을 표현하기 위해서 '%s'을 사용한 사례다.
여기서 왜 부동 소수점 형식이 '%f' 대신에 '%g'인지는 질문하지 말아주세요.
\index{예외!자료형 오류}
\index{자료형 오류}


::: panel-tabset
### R

```{webr-r}
#| label: r-string-matching
sprintf('In %d years I have spotted %g %s', 3, 0.1, 'camels')
#> [1] "In 3 years I have spotted 0.1 camels"

str_glue('In {3} years I have spotted {0.1} {"camels"}')
#> In 3 years I have spotted 0.1 camels
```

### 파이썬

```{pyodide-python}
#| label: py-string-matching
# `format` 메서드
result = 'In {} years I have spotted {} {}'.format(3, 0.1, 'camels')
print(result)
#> In 3 years I have spotted 0.1 camels

# `f-string`
years = 3
camels = 0.1
result = f'In {years} years I have spotted {camels} {"camels"}'
print(result)
#> In 3 years I have spotted 0.1 camels
```
:::

문자열 서식 순서와 갯수는 일치해야 하고, 요소의 자료형(type)도 서식 순서와 일치해야 한다.

::: panel-tabset
### R

```{webr-r}
#| label: r-string-type-error
sprintf('%d %d %d', 1, 2)
#> sprintf("%d %d %d", 1, 2)에서 다음과 같은 에러가 발생했습니다:인자들의 수가 너무 적습니다
sprintf('%d', 'dollars')
#> sprintf("%d", "dollars")에서 다음과 같은 에러가 발생했습니다: '%d'는 유효하지 않은 포맷입니다; 문자형 객체들에는 포맷 %s를 사용해주세요

```

### 파이썬

```{pyodide-python}
#| label: py-string-type-error
'%d %d %d' % (1, 2)
#> TypeError: not enough arguments for format string
'%d' % 'dollars'
#> TypeError: %d format: a number is required, not str
```
:::

상기 첫 예제는 충분한 요소 개수가 되지 않고, 두 번째 예제는 자료형이 맞지 않는다.
서식 연산자는 강력하지만, 사용하기가 까다로운 점이 있으니, `str_glue`를 사용하는 것도 권장된다.

## 디버깅 {#r-string-debug}
\index{디버깅}

프로그램을 작성하면서 배양해야 하는 기술은 항상 자신에게 질문을 하는 것이다.
"여기서 무엇이 잘못될 수 있을까?" 혹은 "내가 작성한 완벽한 프로그램을 망가뜨리기 위해 사용자는 무슨 엄청난 일을 할 것인가?"

예를 들어 앞장의 반복 while 루프를 시연하기 위해 사용한 프로그램을 살펴봅시다.

::: panel-tabset
### R

```{webr-r}
#| label: r-string-debug
while(TRUE) {
  line <- readline(prompt = '> ')
  if(substr(line,1,1) == "#") {
    next
  }
  if(line == 'done') {
    break
  }
  print(line)
}

```

### 파이썬

```{pyodide-python}
#| label: py-string-debug
while True:
    line = input('> ')
    if line[0] == '#':
        continue
    if line == 'done':
        break
    print(line)
print('Done!')
```
:::

사용자가 입력값으로 빈 공백 줄을 입력하게 될 때 무엇이 발생하는지 살펴봅시다.

``` bash
> hello there
[1] hello there
> # don't print this
> print this!
[2] print this!
> 
[1] ""
> done
```

빈 공백 줄이 입력될 때까지 코드는 잘 작동한다.
그리고 나서, 파이썬의 경우 0번째 문자가 없어서 트레이스백(traceback)이 발생한다.
R의 경우 정상 실행되지만 원하는 바는 아니다.
입력 줄이 비어있을 때, 코드 3번째 줄을 "안전"하게 만드는 두 가지 방법이 있다.

하나는 빈 문자열이면 거짓(FALSE)을 반환하도록 `str_detect()` 함수를 사용하는 것이다.

::: columns
::: {.column width="47.5%"}
### R {.unnumbered}

`if(str_detect(line, '^#'))`
:::

::: {.column width="5%"}
:::

::: {.column width="47.5%"}
### 파이썬 {.unnumbered}

`if line.startswith('#') :`
:::
:::

**가디언 패턴(guardian pattern)**을 사용한 `if`문으로 문자열에 적어도 하나의 문자가 있는 경우만 두 번째 논리 표현식이 평가되도록 코드를 작성한다.
\index{가디언 패턴}
\index{패턴!가디언}

::: columns
::: {.column width="47.5%"}
### R {.unnumbered}

`if(str_length(line) > 0 & str_detect(line, '^#'))`
:::

::: {.column width="5%"}
:::

::: {.column width="47.5%"}
### 파이썬 {.unnumbered}

`if len(line) > 0 and line[0] == '#' :`
:::
:::

## AI와 함께하는 문자열 처리 {#r-string-ai}

문자열 처리는 AI 코딩 도구가 특히 강점을 발휘하는 영역이다. 복잡한 텍스트 변환, 패턴 추출, 데이터 정제 작업을 AI에게 요청할 때 다음과 같은 명세 패턴을 활용한다.

### 명세 작성 패턴

AI에게 문자열 처리를 요청할 때 포함해야 할 정보:

1. **입력 데이터 형태**: 처리할 문자열의 구조와 예시
2. **원하는 출력 형태**: 기대하는 결과물의 형태와 예시
3. **경계 조건**: 빈 문자열, 특수문자, 다국어 등 예외 상황

### 프롬프트 예시

**이메일 주소 추출**

> 다음 형식의 로그 라인에서 도메인(@뒤 부분)만 추출하는 R/Python 함수를 작성해줘.
>
> 입력 예시: `"From user@example.com Sat Jan 5 09:14:16 2008"`
>
> 출력 예시: `"example.com"`
>
> 조건: 이메일이 없는 라인은 빈 문자열 반환

**텍스트 정규화**

> 사용자 입력 문자열을 정규화하는 함수가 필요해.
>
> - 앞뒤 공백 제거
> - 연속된 공백은 하나로
> - 모두 소문자로 변환
>
> 입력: `"  Hello   WORLD  "`
>
> 출력: `"hello world"`

**패턴 기반 분리**

> CSV 형식이 아닌 고정 너비 텍스트 파일을 파싱해야 해.
>
> 형식: 이름(20자) + 나이(3자) + 도시(15자)
>
> 예시 라인: `"홍길동              025서울           "`
>
> 결과: 리스트나 데이터프레임으로 분리

이처럼 구체적인 입출력 예시와 경계 조건을 명시하면, AI가 정확한 코드를 생성할 가능성이 높아진다. 앞서 배운 슬라이싱, 문자열 함수, 정규표현식 개념을 알고 있으면 AI가 생성한 코드를 검증하고 수정하는 것도 수월해진다.

## 용어 정의 {#r-string-terminology}

-   **계수기(counter)**: 무언가를 계수하기 위해서 사용되는 변수로 일반적으로 0으로 초기화하고 나서 증가한다.
\index{계수기}
-   **빈 문자열(empty string)**: 두 인용부호로 표현되고, 어떤 문자도 없고 길이가 0인 문자열.
\index{빈 문자열}
-   **서식 연산자(format operator)**: 서식 문자열과 튜플을 받아, 서식 문자열에 지정된 서식으로 튜플 요소를 포함하는 문자열을 생성하는 연산자.
\index{서식 연산자}
\index{연산자!서식}
-   **서식 순서(format sequence)**: d처럼 어떤 값의 서식으로 표현되어야 하는지를 명세하는 "서식 문자열" 문자 순서.
\index{서식 순서}
-   **서식 문자열(format string)**: 서식 순서를 포함하는 서식 연산자와 함께 사용되는 문자열.
\index{서식 문자열}
-   **플래그(flag)**: 조건이 참인지를 표기하기 위해 사용하는 불 변수(boolean variable)
\index{플래그}
-   **호출(invocation)**: 메서드를 호출하는 명령문.
\index{호출}
-   **불변(immutable)**: 순서의 항목에 대입할 수 없는 특성.
\index{불변}
-   **인덱스(index)**: 문자열의 문자처럼 순서(sequence)에 항목을 선택하기 위해 사용되는 정수 값.
\index{인덱스}
-   **항목(item)**: 순서에 있는 값의 하나.
\index{항목}
-   **메서드(method)**: 객체와 연관되어 점 표기법을 사용하여 호출되는 함수.
\index{메서드}
-   **객체(object)**: 변수가 참조하는 무엇. 지금은 "객체"와 "값"을 구별 없이 사용한다.
\index{객체}
-   **검색(search)**: 찾고자 하는 것을 찾았을 때 멈추는 순회 패턴.
\index{검색}
-   **순서(sequence)**: 정돈된 집합. 즉, 정수 인덱스로 각각의 값이 확인되는 값의 집합.
\index{순서}
-   **슬라이스(slice)**: 인덱스 범위로 지정되는 문자열 부분.
\index{슬라이스}
-   **순회(traverse)**: 순서(sequence)의 항목을 반복적으로 훑기, 각각에 대해서는 동일한 연산을 수행.
\index{순회}

## 연습문제 {#r-string-ex .unnumbered}

1.  다음 문자열에서 숫자를 뽑아내는 R 코드를 작성하라.

`str <- 'X-DSPAM-Confidence: 0.8475'`

`str_locate()` 함수와 문자열 슬라이싱을 사용하여 `str_sub()` 문자 뒤 문자열을 뽑아내고 `as.numeric()` 함수를 사용하여 뽑아낸 문자열을 부동 소수점 숫자로 변환하라.
