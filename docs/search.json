[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "챗GPT 코딩",
    "section": "",
    "text": "서문\n지난 몇 년간, 인공지능(AI)의 발전은 우리가 코드를 이해하고 데이터를 바라보는 방식을 근본적으로 바꾸어 놓았습니다. AI가 코드 초안을 작성해주고, 막혔던 질문에 길을 터주는 시대에, 어떤 역량을 갖춰야 할까요? 넘쳐나는 정보와 도구 속에서 길을 잃지 않고, 데이터로부터 진정한 가치를 만들어내는 전문가로 성장하려면 무엇을 배워야 할까요?\n많은 이들이 데이터 과학 프로젝트를 ’일회성 실험’으로 생각합니다. 데이터를 가져와 모델을 만들고, 결과를 보고하는 작업은 분명 중요합니다. 하지만 거기서 멈춘다면, 그 노력은 파편적인 코드와 지식으로만 남게 됩니다. AI에게 복잡한 작업을 맡기더라도, 그 결과가 얼마나 믿을 수 있는지, 내일 또 다른 데이터가 들어왔을 때 전체 과정을 손쉽게 반복할 수 있는지 확신하기 어렵습니다.\n이 책은 그 한계를 넘어서기 위한 여정으로의 초대입니다.\n단순히 코딩 문법이나 AI 도구 사용법을 나열하는 데 그치지 않고, 이 책은 ‘스스로 살아 움직이며 가치를 창출하는 지능형 데이터 시스템’ 을 구축하는 전체 과정을 안내합니다. 이 책에서 펼쳐질 여정은 다음과 같습니다.\n첫 단계는 전문가의 작업실처럼 체계적인 프로젝트 관리, git을 활용한 버전 관리, 테스트를 통해 실수를 줄이는 법을 배우며 견고한 토대를 다지는 것입니다.\n그 위에서, AI라는 강력한 도구를 단순한 장난감이 아닌, 그 결과물을 검증하고 신뢰할 수 있는 지적인 동료로 만드는 방법을 탐구합니다.\n나아가 이 모든 과정을 자동화하여, 버튼 클릭 한 번, 혹은 정해진 시간마다 스스로 전체 데이터 작업을 수행하고 결과를 도출하는 효율성의 극치를 경험하게 될 것입니다.\n이 책의 최종 목표는, 이 모든 것을 통합하여 매일 새로운 데이터를 바탕으로 AI의 지능을 빌려 새로운 지식을 창출하고, 그 결과를 정해진 형태로 만들어내는 하나의 완전한 ’자동화된 지능형 시스템’을 완성하는 것입니다.\n이 책을 덮을 때쯤, 독자 여러분은 단순히 코드를 작성하는 사람을 넘어, 신뢰할 수 있고 자동화된 데이터 시스템을 설계하고 구축하는 전문가로 성장해 있을 것입니다. AI의 시대, 데이터로 진짜 문제를 해결하는 전문가가 되기 위한 여정을 이제 시작하겠습니다.",
    "crumbs": [
      "서문"
    ]
  },
  {
    "objectID": "index.html#감사의-글",
    "href": "index.html#감사의-글",
    "title": "챗GPT 코딩",
    "section": "감사의 글",
    "text": "감사의 글\n\n이 책이 탄생할 수 있도록 도움을 주신 여러분께 깊은 감사의 마음을 표합니다.\n공익법인 한국 R 사용자회가 없었다면 데이터 과학분야 챗GPT 시리즈가 세상에 나오지 못했을 것입니다. 한국 R 사용자회의 유충현 회장님, 신종화 사무처장님, 홍성학 감사님, 올해부터 새롭게 공익법인 한국 R 사용자를 이끌어주실 형환희 회장님께 감사드립니다.\n또한 이 책은 2014년 처음 몸담게 된 소프트웨어 카펜트리 그렉 윌슨 박사님과 Python for Informatics 저자인 미시건 대학 찰스 세브란스 교수님을 비롯한 전세계 수많은 익명의 기여자들의 노력과 지원이 있었고, 서울 R 미트업에서 발표해주시고 참여해주신 수많은 분들이 격려와 영감을 주셨기에 가능했습니다.\n이 책이 출간되는데 있어 이들 모든 분들의 도움 없이는 어려웠을 것입니다. 그동안의 관심과 지원에 깊은 감사를 드리며, 이 책이 데이터 과학의 발전과 독자들에게 도움이 될 수 있기를 바라는 마음으로 마무리하겠습니다.\n\n2024년 3월 속초 청초호\n이광춘",
    "crumbs": [
      "서문"
    ]
  },
  {
    "objectID": "ide.html",
    "href": "ide.html",
    "title": "1  IDE 선택과 발전",
    "section": "",
    "text": "1.1 IDE 탄생과 발전\n소프트웨어 개발 세계는 끊임없이 진화하는 도구 생태계다. 중심에는 개발자 생산성을 극대화하는 통합 개발 환경(IDE, Integrated Development Environment)이 있다. IDE는 단순한 코드 편집기를 넘어, 컴파일, 디버깅, 버전 관리 등 개발 전 과정을 하나의 창에서 처리하는 강력한 작업 공간이다.\n모든 개발자에게 완벽한 단 하나의 IDE는 없다. 프로젝트 종류, 주 사용 언어, 개발 스타일에 따라 최적 도구는 달라진다. 본문에서는 IDE 역사부터 최신 AI 트렌드까지 살펴보고, 자신에게 맞는 IDE 선택과 구성에 필요한 지식을 다룬다.\n그림 1.1 는 VS Code 기반 현대 데이터 과학 IDE(Positron, Cursor 등) 아키텍처다. 클라이언트 레이어(UI), Extension Host(확장 프로그램 실행), 커널 레이어(코드 실행), 외부 서비스 연동이 명확히 분리되어 있다.\nIDE 역사는 ’어떻게 하면 개발을 더 편하고 효율적으로 할 수 있을까?’라는 고민의 역사와 같다.",
    "crumbs": [
      "**5부** 통합 개발 환경",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>IDE 선택과 발전</span>"
    ]
  },
  {
    "objectID": "ide.html#sec-ide-history",
    "href": "ide.html#sec-ide-history",
    "title": "1  IDE 선택과 발전",
    "section": "",
    "text": "초창기 (1970년대): 다트머스 베이직(Dartmouth BASIC)과 같이 편집, 컴파일, 디버깅을 하나의 명령어 기반 환경에서 처리하려는 초기 형태의 IDE가 등장했습니다.\nGUI의 등장 (1980-90년대): 터보 파스칼(Turbo Pascal), 비주얼 베이직(Visual Basic) 등 그래픽 인터페이스(GUI)를 갖춘 IDE가 등장하며, 개발자가 화면을 보며 직관적으로 프로그램을 설계하는 시대를 열었습니다.\n오픈소스와 전문화 (2000년대): 이클립스(Eclipse)와 같은 강력한 오픈소스 IDE가 등장했고, 자바(Java), C++ 등 특정 언어에 최적화된 전문 IDE들이 발전했습니다.\n지능과 클라우드 시대 (2010년대 이후): GitHub Copilot과 같은 AI 코딩 비서가 등장하고, 웹 브라우저에서 모든 개발을 처리하는 클라우드 IDE가 새로운 표준으로 자리 잡고 있습니다.",
    "crumbs": [
      "**5부** 통합 개발 환경",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>IDE 선택과 발전</span>"
    ]
  },
  {
    "objectID": "ide.html#sec-ide-features",
    "href": "ide.html#sec-ide-features",
    "title": "1  IDE 선택과 발전",
    "section": "1.2 IDE 핵심 기능",
    "text": "1.2 IDE 핵심 기능\n대부분 현대 IDE는 다음 공통 기능을 제공한다.\n\n지능형 소스 코드 편집기: 단순 텍스트 편집을 넘어, 구문 강조, 코드 자동 완성(IntelliSense), 실시간 오류 검출 등 코드를 이해하고 돕는 편집기다.\n디버거: 코드 특정 지점에서 실행을 멈추고(breakpoint), 변수 상태를 추적하며 버그를 찾는 필수 도구다.\n빌드 및 실행 자동화: 복잡한 컴파일, 빌드, 실행 과정을 버튼 클릭 한 번으로 자동화한다.\n버전 관리 통합: Git 같은 버전 관리 시스템을 내장해 코드 변경을 추적하고 팀원과 협업한다.",
    "crumbs": [
      "**5부** 통합 개발 환경",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>IDE 선택과 발전</span>"
    ]
  },
  {
    "objectID": "ide.html#sec-ide-evolution",
    "href": "ide.html#sec-ide-evolution",
    "title": "1  IDE 선택과 발전",
    "section": "1.3 현대 개발 환경의 진화",
    "text": "1.3 현대 개발 환경의 진화\n최근 IDE는 특정 개발 영역에 깊이 파고들거나, AI로 개발 방식을 근본적으로 바꾸고 있다.\n\n1.3.1 데이터 과학 IDE 주요 기능\n\n데이터 시각화 도구: 코드 실행 결과 플롯이나 그래프를 IDE 내에서 직접 확인하고 상호작용한다.\n변수 탐색기: 현재 실행 환경의 데이터프레임, 변수, 객체 등을 쉽게 확인하고 관리한다.\nJupyter Notebook 통합: 코드, 텍스트, 시각화를 하나의 문서로 통합 작업한다.\n패키지 및 환경 관리: Conda, venv 등 데이터 과학 라이브러리 패키지와 가상 환경을 관리한다.\n\n\n\n1.3.2 IDE와 프로그래밍 언어 연결: 커널 아키텍처\nVS Code나 주피터(Jupyter) 같은 하나의 IDE가 Python, R, Julia, SQL 등 수십 가지 언어 코드를 실행하고, 결과를 표나 그래프로 받아오는 비결은 커널(Kernel) 아키텍처에 있다.\n주피터 프로젝트에서 시작해 이제는 많은 IDE 표준이 된 커널 아키텍처는 IDE(프론트엔드)와 언어 실행 엔진(백엔드) 분리가 핵심이다.\n\n프론트엔드 (사용자 인터페이스)\n\n개발자가 코드를 입력하는 UI 부분이다. (예: Jupyter Notebook 코드 셀, VS Code 인터랙티브 창)\n프론트엔드는 코드 실행 능력이 없다. 사용자 코드 입력을 받아 커널에 전달하는 메신저 역할만 한다.\n\n커널 (언어 실행 엔진)\n\n실제 코드 실행을 담당하는 별도 독립 프로세스다. Python 코드 실행 시 IPython 커널이, R 코드 실행 시 IRkernel이 백그라운드에서 동작한다.\n커널은 프론트엔드로부터 코드 실행 요청을 받아, 해당 언어 인터프리터로 코드를 실행한다.\n\n통신 프로토콜 (ZMQ와 메시지 스펙)\n\n프론트엔드와 커널은 ZeroMQ(ZMQ) 고성능 메시징 라이브러리로 메시지를 주고받는다.\n메시지 종류와 형식은 주피터 메시징 프로토콜로 표준화되어 있다:\n\nexecute_request: 프론트엔드가 커널에 코드 실행을 요청\nstream: 커널이 print() 같은 텍스트 출력 결과를 프론트엔드로 실시간 전송\ndisplay_data: 커널이 그래프, 이미지, 표 등을 특정 포맷(image/png, text/html)으로 포장해 전송\nexecute_reply: 커널이 코드 실행 완료를 알림\n\n\n\n다양한 언어 확장성\n커널 아키텍처의 가장 큰 장점은 확장성이다. 새로운 언어(예: ‘랭귀지 X’) 지원을 위해서는 Jupyter 메시징 프로토콜을 따르는 ’랭귀지 X 커널’만 만들면 된다. IDE 프론트엔드는 수정할 필요가 없다.\n주피터 생태계가 수백 개 언어 커널을 가질 수 있고, VS Code가 Python 확장 프로그램 하나로 복잡한 데이터 과학 워크플로우를 지원하는 비결이 여기 있다. 언어 서버 프로토콜(LSP, Language Server Protocol)이 언어 ‘분석’ 기능을 분리하고 표준화한 것처럼, 커널 아키텍처는 언어 ‘실행’ 기능을 분리하고 표준화해 놀라운 유연성과 확장성을 제공한다.\n\n\n\n\n\n\n그림 1.2: 커널 아키텍처: 프론트엔드와 실행 엔진의 분리\n\n\n\n그림 1.2 는 IDE 프론트엔드(사용자 인터페이스)와 커널(언어 실행 엔진) 분리 구조와 ZeroMQ, Jupyter 메시징 프로토콜을 통한 통신을 보여준다. 이 분리 덕분에 하나의 IDE가 여러 프로그래밍 언어를 지원한다.\n\n\n1.3.3 AI 에이전트 개발 환경\n최근 LLM 활용 AI 에이전트 개발이 급부상하며 특화된 개발 환경이 등장했다.\n\n특징: 에이전트 동작 흐름을 시각적으로 설계하고, 여러 에이전트 간 상호작용을 테스트하며, 복잡한 프롬프트 체인을 관리한다.\n대표 도구: LangSmith는 LangChain 기반 에이전트 동작을 추적하고 디버깅하는 플랫폼이다. AutoGen Studio는 여러 에이전트 팀을 손쉽게 만들고 테스트하는 시각 인터페이스를 제공한다. Flowise, Langflow 같은 도구도 코드 없이 LLM 애플리케이션을 만드는 시각 IDE 역할을 한다.\n\n\n\n1.3.4 미래 IDE: AI와 CLI 결합\n개발 환경은 AI와 CLI(Command-Line Interface) 결합으로 더욱 강력해지고 있다.\n\nAI 코딩 어시스턴트: GitHub Copilot이나 JetBrains AI Assistant 같은 도구는 IDE에 깊이 통합되어 코드 생성, 디버깅, 테스트 작성 등 개발 전 과정을 돕는 AI 동료가 되고 있다.\nCLI 재발견: Gemini CLI 같은 CLI 기반 AI 도구는 키보드 중심 빠른 작업을 선호하는 개발자가 터미널에서 AI 능력을 활용하게 한다. IDE 통합 터미널에서 CLI 도구를 사용하는 것은 GUI 편리함과 CLI 강력함을 결합하는 현대 개발 방식 핵심이다.",
    "crumbs": [
      "**5부** 통합 개발 환경",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>IDE 선택과 발전</span>"
    ]
  },
  {
    "objectID": "ide.html#sec-ide-conclusion",
    "href": "ide.html#sec-ide-conclusion",
    "title": "1  IDE 선택과 발전",
    "section": "1.4 결론: 자신에게 맞는 IDE 선택",
    "text": "1.4 결론: 자신에게 맞는 IDE 선택\n완벽한 IDE는 없다. 오직 ‘자신에게 맞는’ IDE만 있을 뿐이다. 최적 IDE 선택과 구성 기준은 다음과 같다.\n\n주력 언어와 플랫폼: Java 개발자라면 IntelliJ IDEA, iOS 개발자라면 Xcode, R 사용자라면 RStudio/Positron이 좋은 출발점이다.\n프로젝트 종류: 웹 프론트엔드 개발에는 VS Code, 데이터 분석에는 JupyterLab이나 Spyder, AI 에이전트 개발에는 LangSmith 같은 전문 도구가 효율적이다.\n개발 스타일: 시각 인터페이스와 마우스 클릭을 선호한다면 GUI 중심 IDE를, 키보드와 명령어로 모든 것을 제어하려면 터미널과 CLI 확장이 강력한 IDE를 선택한다.\nAI 기능 활용도: 최신 AI 기능을 적극 활용하려면 GitHub Copilot 통합이 잘 된 VS Code나, AI 네이티브로 설계된 Cursor를 고려한다.\n\nIDE는 개발자 장인의 작업대다. 다양한 도구 특징을 이해하고, 자신의 작업 스타일에 맞게 작업대를 구성할 때 최고의 생산성과 만족감을 얻는다.",
    "crumbs": [
      "**5부** 통합 개발 환경",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>IDE 선택과 발전</span>"
    ]
  },
  {
    "objectID": "ide_positron.html",
    "href": "ide_positron.html",
    "title": "2  포지트론",
    "section": "",
    "text": "2.1 Positron 철학\n데이터 과학 세계는 빠르게 변화하고 있으며, 이제 R과 Python 두 강력한 언어를 함께 사용하는 것이 표준이 되었다. R은 통계 분석과 시각화에 독보적 강점을 가지며, Python은 머신러닝, 범용 프로그래밍, 시스템 통합에 널리 쓰인다. 하지만 오랫동안 데이터 과학자들은 두 언어를 동시에 편안하게 사용할 완벽한 통합 개발 환경(IDE)을 찾기 어려웠다. R 사용자에게는 RStudio가, Python 사용자에게는 다양한 선택지가 있었지만, 두 세계를 자연스럽게 넘나들기에는 항상 아쉬움이 남았다.\n이런 문제의식에서 출발한 것이 Posit(과거 RStudio)사가 개발한 차세대 데이터 과학 IDE 포지트론(Positron)이다. 포지트론은 “하나의 팀, 두 개의 언어” 현실을 받아들이고, R과 Python을 모두 일급 시민(first-class citizen)으로 대우하는 현대 ‘다국어(polyglot)’ 개발 환경을 지향한다.\nPositron 핵심 철학은 RStudio의 데이터 과학 전문성과 Visual Studio Code(VS Code)의 현대적 개발 경험 결합이다. Positron은 VS Code 오픈소스 버전인 ‘Code OSS’ 기반으로 구축되었다. VS Code의 빠르고 유연한 인터페이스, 방대한 확장 기능 생태계, 강력한 코드 편집 기능을 가져오면서, RStudio가 수십 년간 쌓은 데이터 과학 워크플로우 이해를 녹여냈다.",
    "crumbs": [
      "**5부** 통합 개발 환경",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>포지트론</span>"
    ]
  },
  {
    "objectID": "ide_positron.html#sec-positron-philosophy",
    "href": "ide_positron.html#sec-positron-philosophy",
    "title": "2  포지트론",
    "section": "",
    "text": "노트왜 RStudio를 두고 Positron을 만들었나?\n\n\n\nPosit 답변은 명확하다: “RStudio는 계속된다.”\nPositron 개발은 RStudio 대체가 아니다. 두 IDE는 서로 다른 목표와 사용자를 가진다.\n\nRStudio는 R 언어에 깊이 집중하는 데이터 분석가와 통계학자를 위한 최고의 R 개발 환경으로 계속 발전하고 유지된다.\nPositron은 R과 Python을 함께 사용하는 다국어 데이터 과학 팀과 개발자를 위한 새로운 선택지다.\n\nPositron은 ‘R 전용’ RStudio 성공적 틀을 넘어, ’R과 Python 모두’를 필요로 하는 현대 데이터 과학 새로운 요구에 부응하기 위한 Posit 전략적 확장이다.",
    "crumbs": [
      "**5부** 통합 개발 환경",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>포지트론</span>"
    ]
  },
  {
    "objectID": "ide_positron.html#sec-positron-ai",
    "href": "ide_positron.html#sec-positron-ai",
    "title": "2  포지트론",
    "section": "2.2 AI 시대 Positron",
    "text": "2.2 AI 시대 Positron\nPositron 가장 큰 혁신은 단순 다국어 지원을 넘어, AI 기능을 데이터 과학 워크플로우에 깊이 통합한 점이다. Positron AI 어시스턴트는 일반 코딩 도우미와 달리, 현재 실행 중인 R/Python 세션 내부 상태(메모리 데이터, 변수, 플롯 등)를 직접 파악하고 상호작용한다. 데이터 과학자에게 다음 새로운 경험을 제공한다.\n\n탐색적 데이터 분석(EDA) 가속화: AI에게 “penguins 데이터셋에서 종(species)별로 몸무게(body_mass_g) 분포를 박스플롯으로 그려줘” 같이 자연어로 요청할 수 있다. Positron AI는 현재 메모리에 있는 penguins 데이터프레임 구조를 이해하고, 즉시 ggplot2나 matplotlib 코드를 생성해 실행 결과를 플롯 창에 보여준다. 데이터 탐색 초기 단계를 매우 빠르게 단축한다.\n복잡한 데이터 전처리 코드 자동화: “결측치가 있는 행을 제거하고, ‘bill_length_mm’와 ’bill_depth_mm’ 열만 선택해줘” 같은 데이터 전처리(data wrangling) 작업을 AI가 dplyr이나 pandas 코드로 즉시 변환한다. 개발자는 세부 문법을 기억하는 데 에너지를 쏟지 않고, 데이터 분석의 큰 그림과 로직에 집중한다.\n코드와 결과에 대한 지능적 해석: “방금 실행한 선형 회귀 모델의 R-squared 값은 무엇을 의미하지?” 또는 “복잡한 purrr 코드를 단계별로 설명해줘” 같이, AI가 코드뿐 아니라 통계 모델 결과나 분석 과정에 대한 깊이 있는 해석을 제공한다. 데이터 과학자가 더 나은 통찰(insight)을 얻도록 돕는 지능형 파트너 역할을 한다.",
    "crumbs": [
      "**5부** 통합 개발 환경",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>포지트론</span>"
    ]
  },
  {
    "objectID": "ide_positron.html#sec-positron-comparison",
    "href": "ide_positron.html#sec-positron-comparison",
    "title": "2  포지트론",
    "section": "2.3 IDE 비교와 선택",
    "text": "2.3 IDE 비교와 선택\n\n\n\n\n\n\n\n\n\n특성\nRStudio\nVS Code\nPositron\n\n\n\n\n주력 언어\nR\n범용 (모든 언어)\nR & Python\n\n\n주요 사용자\nR 데이터 분석가, 통계학자\n모든 종류의 개발자\n다국어 데이터 과학자\n\n\n설정\n거의 불필요 (R 최적화)\n높은 유연성 (직접 구성)\n낮은 설정 (R/Python 최적화)\n\n\n장점\nR 생태계 완벽 통합\n최고의 유연성과 확장성\nR/Python 동시 작업 및 AI 통합\n\n\n단점\nPython 지원 제한적\n데이터 과학 초기 설정 복잡\n일부 고급 기능 아직 개발 중\n\n\n\n\nR만 사용: 여전히 RStudio가 가장 안정적이고 편리하다.\n웹 개발 등 범용 프로그래밍이 주 목적: 수많은 확장 기능을 갖춘 VS Code가 최고 유연성을 제공한다.\nR과 Python을 함께 사용하며 최신 AI 기능을 적극 활용: Positron은 두 언어를 매끄럽게 오가며 AI 지원을 받을 수 있는 현재 가장 진보적 환경이다.",
    "crumbs": [
      "**5부** 통합 개발 환경",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>포지트론</span>"
    ]
  },
  {
    "objectID": "ide_positron.html#sec-positron-conclusion",
    "href": "ide_positron.html#sec-positron-conclusion",
    "title": "2  포지트론",
    "section": "2.4 결론",
    "text": "2.4 결론\nPositron은 아직 베타 버전이며 RStudio 일부 기능(예: R Markdown 프로파일링, 간편한 앱 배포)이 아직 구현되지 않았다는 한계가 있다. 하지만 R과 Python이 공존하는 현대 데이터 과학 흐름을 가장 잘 반영하고, AI를 개발 워크플로우 핵심으로 가져왔다는 점에서 미래가 기대된다.\nPositron은 단순히 새로운 도구가 아니라, Posit 팀이 그리는 ‘미래 데이터 과학 작업 환경’ 청사진이다. AI와 함께 더 빠르고 깊이 있게 데이터 문제를 해결하고 싶은 데이터 과학자라면, Positron은 여정을 함께할 흥미로운 파트너다.",
    "crumbs": [
      "**5부** 통합 개발 환경",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>포지트론</span>"
    ]
  },
  {
    "objectID": "ide_extension.html",
    "href": "ide_extension.html",
    "title": "3  IDE 확장 프로그램",
    "section": "",
    "text": "3.1 IDE 확장 프로그램 필요성\n현대 통합 개발 환경(IDE)의 가장 큰 힘은 ’확장성’에 있다. 어떤 IDE도 세상의 모든 프로그래밍 언어, 프레임워크, 도구를 기본 지원할 수는 없다. 그렇게 시도한다면 IDE는 극도로 무거워지고 복잡해져 사용할 수 없게 된다.\n문제 해결의 핵심 아이디어가 바로 확장 프로그램(Extensions)이다. IDE는 핵심 기능(텍스트 편집, UI)만 제공하고, 추가 기능들은 사용자가 필요에 따라 ’레고 블록’처럼 조립해 사용한다. 본문에서는 IDE 확장 프로그램이 왜 필요하며, 어떤 아키텍처로 안정적으로 구현되는지 설명한다.",
    "crumbs": [
      "**5부** 통합 개발 환경",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>IDE 확장 프로그램</span>"
    ]
  },
  {
    "objectID": "ide_extension.html#sec-extension-need",
    "href": "ide_extension.html#sec-extension-need",
    "title": "3  IDE 확장 프로그램",
    "section": "",
    "text": "새로운 기술에 대한 유연한 대응: 프로그래밍 언어, 프레임워크, 도구는 끊임없이 등장하고 변화한다. 확장 프로그램 모델은 IDE 개발팀이 모든 기술을 직접 지원하지 않고도, 각 기술 커뮤니티나 서드파티 개발자가 직접 확장 프로그램을 만들어 생태계에 기여하게 한다.\n사용자 맞춤형 환경 구축: 모든 개발자는 자신만의 작업 방식과 선호 도구가 있다. 확장 프로그램으로 개발자는 테마, 키보드 단축키, 코드 린터(linter) 등 자신에게 맞는 개발 환경을 구축한다.\n성능과 안정성: 필요한 기능만 선택적으로 설치하고 활성화해 IDE를 가볍고 빠르게 유지한다. 잘 설계된 아키텍처는 하나의 확장 프로그램 오류가 전체 IDE를 마비시키는 것을 방지한다.",
    "crumbs": [
      "**5부** 통합 개발 환경",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>IDE 확장 프로그램</span>"
    ]
  },
  {
    "objectID": "ide_extension.html#sec-extension-architecture",
    "href": "ide_extension.html#sec-extension-architecture",
    "title": "3  IDE 확장 프로그램",
    "section": "3.2 IDE 확장 프로그램 아키텍처",
    "text": "3.2 IDE 확장 프로그램 아키텍처\n안정적이고 유연한 확장성 제공을 위해 현대 IDE는 공통된 아키텍처 패턴을 따른다. Visual Studio Code(VS Code)는 아키텍처를 가장 성공적으로 구현한 대표 사례다.\n\n3.2.1 Extension Host: 확장 프로그램 격리\nVS Code는 확장 프로그램을 IDE 메인 프로세스가 아닌, ‘Extension Host’ 라고 불리는 별도 독립 프로세스에서 실행한다.\n\n목적: 구조의 가장 큰 목적은 안정성이다. 특정 확장 프로그램이 과도한 메모리를 사용하거나 오류를 일으켜 멈추더라도, IDE 메인 프로세스(UI, 텍스트 편집 등)는 전혀 영향을 받지 않는다. 사용자는 문제의 확장 프로그램을 비활성화하거나 재시작할 수 있으며, 작업 내용은 안전하게 보존된다.\n\n\n\n\n\n\n\n그림 3.1: Extension Host: 확장 프로그램 격리 아키텍처\n\n\n\n그림 3.1 는 VS Code가 메인 프로세스와 Extension Host를 분리해 안정성을 확보하는 방식을 보여준다. 확장 프로그램이 오류를 일으켜도 메인 프로세스는 안전하게 작동한다.\n\n\n3.2.2 LSP: 언어 기능 분리\n과거에는 C++ 언어 ‘코드 자동 완성’ 기능을 만들려면, VS Code용, Sublime Text용, Atom용 코드를 각각 따로 만들어야 했다. 언어 개발자(m)와 IDE 개발자(n) 모두에게 m x n의 비효율적 개발 부담을 주었다.\n마이크로소프트가 개발해 표준으로 제안한 언어 서버 프로토콜(Language Server Protocol, LSP)은 문제를 해결했다.\n\n아키텍처: LSP는 언어 관련 기능(코드 분석, 자동 완성, 오류 검출 등)을 ‘언어 서버’ 라는 독립 프로세스로 분리한다. IDE(클라이언트)는 표준화된 JSON-RPC 메시지로 언어 서버와 통신하며 정보를 주고받는다.\n효과: C++ 언어 개발자는 ‘C++ 언어 서버’ 하나만 만들면 된다. LSP를 지원하는 모든 IDE(VS Code, 이클립스, 주피터 등)는 별도 노력 없이 C++ 언어의 모든 지능형 기능을 사용할 수 있다. 개발 부담을 m + n으로 획기적으로 줄였고, 새로운 언어가 빠르게 다양한 IDE에 채택될 수 있는 길을 열었다.\n\n\n\n\n\n\n\n그림 3.2: 언어 서버 프로토콜 (LSP): m × n 문제의 해결\n\n\n\n그림 3.2 는 LSP가 m × n 문제를 m + n으로 해결한 과정을 보여준다. 과거에는 각 언어와 IDE마다 별도 통합 작업이 필요했지만, LSP로 언어 서버 하나만 만들면 모든 LSP 지원 IDE에서 사용할 수 있게 되었다.\n\n\n3.2.3 기능 기여 모델\n확장 프로그램은 package.json이라는 Manifest(설명서) 파일로 IDE 메뉴, 아이콘, 명령어 목록에 자신의 기능을 추가한다.\n\nManifest (package.json): 파일에는 확장 프로그램의 이름, 버전, 설명 등 기본 정보와 함께, ‘어떤 조건에서 활성화될지’(Activation Events), ‘IDE 어느 부분에 어떤 기능을 추가할지’(Contribution Points)가 명시되어 있다.\nContribution Points: VS Code는 확장 프로그램이 기여할 수 있는 ’슬롯’을 미리 정의해 두었다. 예를 들어, contributes.commands는 새로운 명령어를, contributes.menus는 메뉴 항목을, contributes.views는 사이드바에 새로운 UI 창을 추가한다. IDE는 시작될 때 package.json 파일들을 읽어들여 전체 UI와 기능을 구성한다.\n\n\n\n3.2.4 Atom 에디터 사례\nAtom 에디터는 VS Code 성공적 아키텍처를 이해하는 데 좋은 대조 사례다. Atom 역시 Electron 기반으로 만들어졌고 ‘핵킹 가능한(hackable)’ 에디터를 표방하며 엄청난 유연성을 제공했지만, VS Code와 결정적 아키텍처 차이가 있었다.\n\n단일 프로세스 모델: Atom은 VS Code와 달리 확장 프로그램을 격리된 ’Extension Host’에서 실행하지 않았다. 모든 확장 프로그램은 에디터 UI와 동일한 렌더러 프로세스에서 실행되었다.\n결과: 구조는 에디터의 거의 모든 부분을 수정할 수 있는 극강의 자유도를 제공했지만, 치명적 단점을 낳았다. 하나의 확장 프로그램이 오작동하거나 느려지면 에디터 전체가 버벅거리거나 멈추는 현상이 잦았다. 결국 Atom 성능 저하 문제로 이어졌다.\n교훈: Atom 사례는 확장 프로그램 아키텍처에서 ‘격리(isolation)’ 가 왜 중요한지 명확히 보여준다. VS Code가 Extension Host로 안정성과 성능을 모두 잡을 수 있었던 것은 Atom 단점을 반면교사로 삼았기 때문이다. (참고: Atom 프로젝트는 2022년 12월 공식 개발 중단)\n\n\n\n3.2.5 VS Code 아키텍처 영향\n최근 Positron, Cursor 등 많은 IDE가 VS Code 오픈소스 코어인 ‘Code - OSS’ 기반으로 만들어지고 있다. VS Code 확장 프로그램 아키텍처가 그만큼 뛰어나고, 현대 IDE 개발의 ’성공 공식’이 되었다는 의미다.\n\n거대한 생태계의 즉각적 활용: 새로운 IDE가 VS Code 기반으로 만들어진다는 것은, 수만 개의 기존 VS Code 확장 프로그램을 거의 그대로 사용할 수 있다는 뜻이다. 새로운 IDE는 처음부터 모든 언어 지원, 테마, 도구를 만들 필요 없이, 이미 검증된 거대한 생태계를 즉시 활용해 개발을 시작한다.\n검증된 안정성과 성능: VS Code의 ‘Extension Host’ 같은 멀티 프로세스 아키텍처는 안정성과 성능이 이미 검증되었다. 새로운 IDE는 복잡한 기반을 직접 설계하는 대신, 자신만의 핵심적 특화 기능 개발에만 집중한다.\n익숙한 사용자 경험: 전 세계 수많은 개발자가 이미 VS Code의 UI와 사용 방식에 익숙하다. 이 기반으로 만들어진 IDE는 사용자가 별도 학습 없이도 쉽고 빠르게 적응할 수 있다는 큰 장점이 있다.\n\nVS Code 확장 프로그램 아키텍처는 단순 기술적 성공을 넘어, 다른 IDE가 활용할 수 있는 강력한 플랫폼이자 생태계를 창조했다. 많은 현대 IDE가 ’바퀴를 재발명’하는 대신 VS Code라는 거인의 어깨 위에 올라타는 이유다.",
    "crumbs": [
      "**5부** 통합 개발 환경",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>IDE 확장 프로그램</span>"
    ]
  },
  {
    "objectID": "ide_extension.html#sec-extension-conclusion",
    "href": "ide_extension.html#sec-extension-conclusion",
    "title": "3  IDE 확장 프로그램",
    "section": "3.3 결론",
    "text": "3.3 결론\n현대 IDE 확장 프로그램 아키텍처는 ‘분리와 표준화’ 두 가지 핵심 원칙에 기반한다. Extension Host로 각 확장 프로그램을 분리해 안정성을 확보하고, LSP라는 표준화된 프로토콜로 언어 기능을 재사용 가능하게 만든다.\n영리한 아키텍처 덕분에 VS Code 같은 현대 IDE는 수많은 언어와 도구를 지원하는 거대한 생태계를 구축하면서도, 가볍고 안정적인 성능을 유지한다. IDE가 더 이상 하나의 회사가 만드는 단일 제품이 아니라, 전 세계 개발자 커뮤니티가 함께 만들어가는 ’플랫폼’이 되었다.",
    "crumbs": [
      "**5부** 통합 개발 환경",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>IDE 확장 프로그램</span>"
    ]
  },
  {
    "objectID": "ide_setup.html",
    "href": "ide_setup.html",
    "title": "4  개발 환경 구축",
    "section": "",
    "text": "4.1 Git 설치\nAI로 데이터 과학 문제를 해결하기 위한 첫걸음은 강력한 프로그래밍 언어와 안정적인 개발 환경 구축이다. 본 장에서는 필수적인 버전 관리 도구 Git과 재현 가능한 환경을 위한 도커(Docker), 워크플로우 자동화를 위한 Make를 시작으로, 데이터 과학의 양대 산맥인 R과 파이썬(Python)을 설치하고, 마지막으로 이들을 통합해 사용할 포지트론 IDE 설정 전 과정을 안내한다.\n그림 4.1 는 데이터 과학 개발 환경 구축의 전체 단계를 보여준다. Git, 도커, Make 같은 필수 도구를 먼저 설치하고, R과 파이썬을 설치한 후, 마지막으로 포지트론 IDE를 설치한다.\n본격적인 개발 환경 구축에 앞서, 가장 중요한 버전 관리 시스템 Git을 먼저 설치한다. Git은 코드 변경 이력을 추적하고, 여러 개발자가 협업하게 하며, AI 모델 개발 시 다양한 실험을 관리하는 필수 도구다.",
    "crumbs": [
      "**5부** 통합 개발 환경",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>개발 환경 구축</span>"
    ]
  },
  {
    "objectID": "ide_setup.html#sec-setup-git",
    "href": "ide_setup.html#sec-setup-git",
    "title": "4  개발 환경 구축",
    "section": "",
    "text": "4.1.1 Git 설치\n맥OS(macOS)에서는 터미널을 열고 xcode-select --install 명령어를 실행하면 뜨는 팝업창에서 ’설치’를 클릭한다. Xcode Command Line Tools에 Git이 포함되어 있다. 이미 설치되어 있다면 git --version 명령어로 확인한다.\n윈도우(Windows)에서는 git-scm.com 공식 다운로드 페이지에 접속해 최신 버전 설치 파일을 다운로드한다. 설치 프로그램을 실행하고 대부분 옵션을 기본값으로 두고 설치를 진행한다. ’Git Bash’가 함께 설치되어 강력한 명령어 환경을 제공한다.\n리눅스(Linux, 우분투/데비안)에서는 터미널을 열고 다음 명령어를 실행한다:\nsudo apt-get update\nsudo apt-get install git\n\n4.1.2 설치 확인\n터미널에서 다음 명령어를 실행해 Git이 정상 설치되었는지 확인한다:\n$ git --version\ngit version 2.39.2 (Apple Git-143)\n\n4.1.3 최초 설정\nGit 설치 후, 터미널에서 다음 두 명령어를 실행해 사용자 이름과 이메일 주소를 반드시 설정한다. 정보는 코드를 변경하고 저장(커밋)할 때마다 기록된다.\ngit config --global user.name \"Your Name\"\ngit config --global user.email \"youremail@example.com\"\n\"Your Name\"과 \"youremail@example.com\" 부분을 본인의 정보로 바꿔서 입력하세요.",
    "crumbs": [
      "**5부** 통합 개발 환경",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>개발 환경 구축</span>"
    ]
  },
  {
    "objectID": "ide_setup.html#컨테이너-환경-도커-설치",
    "href": "ide_setup.html#컨테이너-환경-도커-설치",
    "title": "4  개발 환경 구축",
    "section": "\n4.2 컨테이너 환경: 도커 설치",
    "text": "4.2 컨테이너 환경: 도커 설치\nAI/머신러닝 프로젝트는 복잡한 라이브러리, 시스템 의존성, 드라이버 버전 등으로 내 컴퓨터에서는 잘 동작하던 코드가 다른 사람의 컴퓨터나 서버에서는 동작하지 않는 ’환경 문제’를 자주 겪는다. 도커는 프로젝트에 필요한 모든 것을 ’컨테이너’라는 격리된 공간에 담아 어디서든 동일한 환경을 완벽하게 복제한다. 재현 가능한 연구와 안정적 배포를 위한 현대 AI 개발 필수 도구다.\n\n\n도커 Desktop 설치:\n\n\n도커 공식 웹사이트에 접속해 자신의 운영체제(맥OS, 윈도우, 리눅스)에 맞는 도커 Desktop을 다운로드하고 설치한다.\n\n\n\n설치 확인: 설치 후 도커 Desktop을 실행한다. 터미널에서 다음 명령어를 실행해 정상 설치를 확인한다:\n$ docker --version\nDocker version 24.0.6, build ed223bc\n\n$ docker run hello-world\nHello from Docker!\nThis message shows that your installation appears to be working correctly.",
    "crumbs": [
      "**5부** 통합 개발 환경",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>개발 환경 구축</span>"
    ]
  },
  {
    "objectID": "ide_setup.html#sec-setup-make",
    "href": "ide_setup.html#sec-setup-make",
    "title": "4  개발 환경 구축",
    "section": "\n4.3 워크플로우 자동화",
    "text": "4.3 워크플로우 자동화\n데이터 과학 프로젝트는 ‘데이터 가져오기 → 전처리 → 모델 학습 → 결과 분석 → 보고서 생성’ 같은 여러 단계 작업 흐름을 가진다. 각 단계를 수동으로 반복 실행하는 것은 비효율적일 뿐 아니라 실수를 유발한다. 1970년대 유닉스 시스템에서 탄생한 make는 이런 반복 작업을 자동화하는 검증된 도구다.\nmake 핵심은 의존성 기반 실행이다. Makefile에 “분석 보고서는 전처리된 데이터에 의존하고, 전처리된 데이터는 원본 데이터에 의존한다”는 관계를 정의하면, make는 변경된 파일만 감지해 필요한 작업만 지능적으로 재실행한다. 예를 들어 원본 데이터가 바뀌면 전처리부터 보고서까지 전부 재생성하지만, 분석 코드만 수정했다면 전처리는 건너뛰고 분석과 보고서만 다시 생성한다. 시간과 컴퓨팅 자원을 크게 절약하는 방식이다.\n\n4.3.1 Make 설치\nmake는 대부분의 운영체제에 이미 설치되어 있거나 개발 도구와 함께 제공된다. 맥OS에서는 Git 설치 시 사용한 Xcode Command Line Tools에 make가 포함되어 있고, 리눅스(우분투/데비안)에서도 기본으로 설치된 경우가 많다. 터미널에서 make --version을 실행해 설치 여부를 확인할 수 있다. 리눅스에서 make가 없다면 sudo apt-get install build-essential 명령어로 컴파일 도구 일체를 설치한다.\n윈도우는 상황이 다르다. Git for Windows를 설치했다면 Git Bash 환경에서 make를 사용할 수 있지만, 네이티브 윈도우 환경에서는 별도 설치가 필요하다. Chocolatey 패키지 매니저가 설치되어 있다면 choco install make 명령어로 간단히 설치할 수 있다.\n\n4.3.2 워크플로우 도구 진화\nmake는 1976년 Stuart Feldman이 Bell Labs에서 C 프로그램 컴파일 자동화를 위해 개발했다. 이후 50년 가까이 소프트웨어 빌드의 표준 도구로 자리잡았지만, 데이터 과학의 부상과 함께 새로운 요구가 생겼다. make의 shell 스크립트 기반 문법은 데이터 분석 파이프라인을 표현하기에 복잡하고, 크로스 플랫폼 지원도 제한적이다. 특히 R이나 Python 생태계와의 통합이 자연스럽지 않다. 이런 한계를 극복하기 위해 언어별, 용도별로 특화된 도구들이 등장했다.\n\n\n\n\n\n그림 4.2: 워크플로우 자동화 도구의 진화\n\n\n지난 50년간 워크플로우 자동화 도구는 세 번의 큰 물결을 거쳤다. 그림 4.2 은 이 진화 과정을 시간순으로 보여준다. 첫 번째 물결은 1976년 make로 시작되었다. C 프로그램 컴파일을 위해 탄생했지만, 곧 소프트웨어 빌드 전반의 표준이 되었다. 두 번째 물결은 2012년 스네이크메이크의 등장이다. 독일 뒤셀도르프 대학의 Johannes Köster가 생물정보학 연구를 위해 개발했는데, 수백 개의 샘플을 처리하는 유전체 분석 파이프라인에서 make의 한계가 명확했기 때문이다. Python 문법을 직접 사용할 수 있고, 클러스터 환경에서 자동 병렬화를 지원하는 스네이크메이크는 곧 생명과학을 넘어 데이터 과학 전반으로 확산되었다. 세 번째 물결은 2017-2020년 사이 동시다발적으로 일어났다. 2017년 Go로 작성된 Task가 YAML 기반의 간결한 문법으로 등장했고, 2018년에는 Rust 기반 Just가 명령어 실행에 특화된 미니멀한 접근으로 개발자들을 끌어모았다. 2020년 R 커뮤니티에서는 Will Landau가 targets를 발표하며 데이터 과학 워크플로우 자동화의 새 장을 열었다. drake 패키지의 후속작인 targets는 R 객체 수준에서 의존성을 추적하고, Quarto와의 완벽한 통합으로 재현가능한 연구의 표준 도구가 되었다.\n\n4.3.3 현대 데이터 과학 도구\nmake가 50년 역사를 자랑하지만, 현대 데이터 과학 프로젝트는 make가 설계되지 않았던 요구사항들을 갖는다. R 데이터 분석 프로젝트는 함수와 데이터 객체 간의 복잡한 의존성을 추적해야 하고, Python 생물정보학 파이프라인은 수천 개의 파일을 클러스터에서 병렬 처리해야 한다. 웹 기반 Quarto 프로젝트는 윈도우와 맥OS, 리눅스에서 동일한 명령어로 작동해야 한다. 이런 특수한 요구를 충족하기 위해 언어별, 용도별로 최적화된 도구들이 등장했다.\n\n\n\n\n\n그림 4.3: 데이터 과학 워크플로우 자동화 도구\n\n\n그림 4.3 는 현대 데이터 과학에서 사용되는 세 가지 워크플로우 자동화 도구를 비교한다. R 커뮤니티는 targets를 통해 데이터 분석의 재현가능성을 한 단계 높였다. 함수 하나를 수정하면 그 함수에 의존하는 모든 타겟이 자동으로 재계산되고, Quarto 보고서까지 연쇄적으로 업데이트된다. Python 생태계는 스네이크메이크로 대규모 데이터 파이프라인을 관리한다. make와 비슷한 규칙 기반 문법에 Python의 강력함을 더해, 생물정보학부터 기계학습 실험 추적까지 폭넓게 활용된다. 범용 빌드 도구로는 Task가 부상했다. YAML 파일 하나로 프로젝트의 모든 반복 작업을 정의하고, 크로스 플랫폼 환경에서 동일하게 실행할 수 있다.\nR 데이터 과학: targets\nR 프로젝트에서는 targets 패키지가 워크플로우 자동화의 표준이다. targets는 함수와 데이터 객체 간의 의존성을 자동으로 추적하고, 변경이 발생한 부분만 재실행한다. 특히 Quarto 문서와의 통합이 뛰어나 데이터 분석부터 보고서 생성까지 하나의 워크플로우로 관리할 수 있다.\nR 콘솔이나 포지트론 터미널에서 다음 명령어로 설치한다:\ninstall.packages(\"targets\")\ninstall.packages(\"tarchetypes\")  # Quarto 통합용\n\n# 설치 확인\nlibrary(targets)\npackageVersion(\"targets\")\ntarchetypes 패키지는 Quarto 문서를 targets 파이프라인에 통합하는 tar_quarto() 함수를 제공한다. 데이터 분석 결과가 변경되면 Quarto 문서도 자동으로 재렌더링된다.\nPython 데이터 과학: Snakemake\n스네이크메이크는 Python 기반 워크플로우 관리 시스템으로, 생물정보학 분야에서 시작해 데이터 과학 전반으로 확산되었다. make와 유사한 규칙 기반 문법에 Python 코드를 결합해 복잡한 파이프라인을 표현할 수 있다. 클러스터나 클라우드 환경에서 대규모 병렬 처리를 지원하며, 재현가능한 연구를 위한 표준 도구로 자리잡았다.\n스네이크메이크는 conda나 pip로 설치할 수 있다. conda를 사용하면 의존성 관리가 자동화되고, 필요한 생물정보학 도구들과 함께 환경을 구성할 수 있다:\n# conda로 설치 (권장 - 범용)\nconda install -c conda-forge snakemake\n\n# 생물정보학 프로젝트라면 bioconda 채널 사용\nconda install -c bioconda snakemake\n\n# pip로도 설치 가능\npip install snakemake\n\n# 설치 확인\nsnakemake --version\nconda-forge는 범용 데이터 과학 프로젝트에 적합하고, bioconda는 유전체 분석 같은 생물정보학 도구들을 함께 사용할 때 유용하다. conda 환경이 없다면 pip로도 충분히 설치할 수 있다.\n범용 빌드: Task\nTask는 make의 현대적 대안으로, YAML 파일에 작업을 정의하고 실행한다. make의 복잡한 문법 대신 읽기 쉬운 YAML을 사용하며, 윈도우와 맥OS, 리눅스 모두에서 동일하게 작동한다. Quarto 프로젝트의 렌더링, 테스트, 배포 같은 반복 작업을 자동화할 때 유용하다.\n운영체제별 설치 방법은 다음과 같다:\n# macOS\nbrew install go-task/tap/go-task\n\n# Windows (Chocolatey)\nchoco install go-task\n\n# Windows (Scoop)\nscoop install task\n\n# Linux\nsh -c \"$(curl --location https://taskfile.dev/install.sh)\" -- -d -b /usr/local/bin\n\n# 설치 확인\ntask --version\n프로젝트 루트에 Taskfile.yml을 생성하고 작업을 정의하면, task 작업명 명령어로 실행할 수 있다. targets나 스네이크메이크처럼 복잡한 의존성 추적은 제공하지 않지만, 간단한 빌드 스크립트를 작성할 때 make보다 훨씬 직관적이다.",
    "crumbs": [
      "**5부** 통합 개발 환경",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>개발 환경 구축</span>"
    ]
  },
  {
    "objectID": "ide_setup.html#sec-setup-isolation-comparison",
    "href": "ide_setup.html#sec-setup-isolation-comparison",
    "title": "4  개발 환경 구축",
    "section": "\n4.4 uv vs 도커",
    "text": "4.4 uv vs 도커\n파이썬 개발 환경 격리 도구인 uv와 도커는 모두 ‘재현 가능한 환경’ 구축을 목표로 하지만, 접근 방식과 범위가 다르다.\n\n\n\n\n\n그림 4.4: 환경 격리 수준 비교: uv vs 도커\n\n\n그림 4.4 는 uv와 도커의 가상화 계층 구조를 보여준다. uv는 파이썬 패키지 수준만 격리하는 반면, 도커는 OS부터 모든 시스템 의존성까지 완전히 격리한다.\n\n4.4.1 유사점\n두 도구 모두 프로젝트마다 독립적 환경을 제공해 의존성 충돌을 방지하는 환경 격리를 목표로 한다. 또한 동일한 환경을 다른 시스템에서 정확히 재현할 수 있는 재현가능성을 보장하며, 프로젝트 의존성을 파일로 명확히 정의한다. uv는 requirements.txt로, 도커는 Dockerfile로 의존성을 명시한다.\n\n4.4.2 차이점\n\n\n\n\n\n\n\n\n특성\nuv\n도커\n\n\n\n격리 수준\n파이썬 패키지 수준 (가상 환경)\nOS 수준 (완전한 컨테이너)\n\n\n범위\n파이썬 패키지만 관리\n파이썬, R, 시스템 라이브러리, OS 설정 등 전체\n\n\n무게\n매우 가볍고 빠름 (러스트 기반)\n상대적으로 무거움 (이미지 크기 수백 MB~GB)\n\n\n시작 속도\n즉시 (초 단위)\n컨테이너 시작 필요 (초~분)\n\n\n학습 곡선\n낮음 (pip/venv 익숙하면 쉬움)\n높음 (Dockerfile, 이미지, 컨테이너 개념)\n\n\n사용 시나리오\n로컬 파이썬 개발\n복잡한 멀티 언어 프로젝트, 배포, CI/CD\n\n\n시스템 의존성\n시스템 라이브러리에 의존\n시스템과 완전 독립\n\n\n\n\n\n\n\n표 4.1: uv와 도커 환경 격리 도구 비교\n\n\n\n\n4.4.3 언제 무엇을 사용하나?\nuv로 충분한 경우:\n순수 파이썬 패키지만 사용하는 프로젝트는 uv로 완벽히 재현 가능하다.\n# 예: 웹 개발, 데이터 분석 기본\npandas, requests, fastapi, pydantic, numpy, scikit-learn\n이런 패키지는 시스템 라이브러리 의존성이 없거나 최소화되어, uv가 파이썬 버전과 패키지만 관리해도 어떤 시스템에서든 동일하게 작동한다.\n도커가 필요한 경우:\n시스템 라이브러리 의존성이 있는 패키지는 도커 권장이다.\n# 예: 컴퓨터 비전, 데이터베이스, 지리정보\nopencv-python     # C++ 라이브러리 (OpenCV)\npsycopg2          # PostgreSQL 라이브러리\nGDAL              # 지리정보 시스템 라이브러리\n이런 패키지는 OS의 시스템 라이브러리가 필요하므로, 도커로 OS부터 완전히 격리하는 것이 안전하다.\n둘 다 사용: 도커 컨테이너 안에서 uv를 사용해 파이썬 패키지를 관리하는 것도 가능하다. 도커로 시스템 라이브러리 환경을 구축하고, uv로 파이썬 패키지를 빠르게 관리하는 조합이다.\n결론: 순수 파이썬 프로젝트는 uv로 시작하고, 시스템 의존성이 생기면 도커를 고려한다.",
    "crumbs": [
      "**5부** 통합 개발 환경",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>개발 환경 구축</span>"
    ]
  },
  {
    "objectID": "ide_setup.html#sec-setup-languages",
    "href": "ide_setup.html#sec-setup-languages",
    "title": "4  개발 환경 구축",
    "section": "\n4.5 코딩 언어 설치",
    "text": "4.5 코딩 언어 설치\nR은 통계 분석, 데이터 시각화, 학술 연구 분야에서 전통적 강점을 가진다. ggplot2 같은 강력한 시각화 라이브러리와 수많은 통계 패키지는 R의 큰 자산이다.\n반면 파이썬은 머신러닝, 딥러닝, 웹 개발, 시스템 자동화 등 범용성과 확장성에서 뛰어나다. TensorFlow, PyTorch 같은 딥러닝 프레임워크와 방대한 커뮤니티를 자랑한다.\n두 언어는 경쟁 관계이기도 하지만, 서로의 단점을 보완하는 강력한 상보 관계이기도 하다. R로 데이터를 깊이 있게 탐색하고 시각화한 후, 파이썬으로 복잡한 머신러닝 모델을 구축하거나 서비스로 배포하는 워크플로우는 매우 효과적이다. 현대 데이터 과학자에게 두 언어 모두를 능숙하게 다루는 능력은 큰 경쟁력이 된다.\n\n4.5.1 R 설치 및 환경 관리\nR 설치\nR은 CRAN(The Comprehensive R Archive Network) 공식 네트워크로 배포된다.\nCRAN 공식 웹사이트에 접속해 자신의 운영체제(리눅스, 맥OS, 윈도우)에 맞는 R 설치 파일을 다운로드하고 실행한다. 설치 과정에서는 대부분 기본 설정을 유지하는 것이 좋다.\n\n참고: RStudio나 Positron은 R을 실행하기 위한 IDE일 뿐, R 자체는 아니다. IDE 사용 전에 반드시 시스템에 R 언어가 먼저 설치되어 있어야 한다.\n\nR 환경 관리: renv\n프로젝트마다 사용하는 R 패키지 버전이 다르면 충돌이 발생할 수 있다. renv는 프로젝트별로 독립된 패키지 라이브러리를 만들어 의존성 문제를 해결하는 도구다.\n중요한 제한사항: renv는 R 패키지만 격리한다. R 인터프리터(언어 실행기) 자체는 시스템에 설치된 것을 공유해 사용한다. renv.lock 파일에 “R 버전 4.3.0”이라고 기록은 하지만, 해당 R 버전이 시스템에 없으면 설치해주지 않고 경고만 표시한다. R 버전까지 완전히 격리하려면 rig (R Installation Manager) 같은 별도 도구와 함께 사용해야 한다.\n이는 파이썬 uv와의 큰 차이다. uv는 uv python install 3.11 명령으로 파이썬 인터프리터 자체를 다운로드하고 관리하지만, renv는 그런 기능이 없다.\n설치 및 사용:\nR 콘솔에서 install.packages(\"renv\")를 실행해 설치한다. RStudio나 Positron에서 새로운 프로젝트를 시작할 때 renv 사용 옵션을 체크하면 프로젝트 폴더에 renv 관련 파일이 생성된다. renv::snapshot()으로 패키지 목록과 버전을 기록하고, renv::restore()로 다른 환경에서 복원한다.\nrig + renv 조합으로 완전한 격리:\nR 버전까지 완전히 격리하려면 rig (R Installation Manager)와 renv를 함께 사용한다. 먼저 rig GitHub에서 운영체제에 맞는 설치 프로그램을 다운로드한다. rig add 4.3.0 명령으로 원하는 R 버전을 설치하고, rig default 4.3.0 또는 .Rprofile 파일로 프로젝트별 R 버전을 고정한다. 이후 renv로 패키지를 관리하면 파이썬 uv처럼 런타임(R 인터프리터)과 패키지 모두 프로젝트별로 격리할 수 있다.\n\n\n\n\n\n그림 4.5: uv vs rig + renv: 런타임 격리 방식 비교\n\n\n\n4.5.2 파이썬 설치 및 환경 관리\n파이썬 설치\n파이썬 설치 방법은 크게 두 가지다.\n공식 파이썬 설치 프로그램 사용 (권장): 파이썬 공식 웹사이트에 접속해 최신 안정화 버전을 다운로드한다. 윈도우 설치 시 첫 화면에서 “Add Python.exe to PATH” 옵션을 반드시 체크해야 터미널에서 python 명령어를 바로 사용할 수 있다. 이 방법은 가장 깔끔하고 표준적인 파이썬 환경을 제공한다.\n아나콘다(Anaconda) 배포판 사용: 아나콘다 배포판은 파이썬 자체뿐 아니라 numpy, pandas, scikit-learn 등 수백 개의 데이터 과학 패키지를 함께 묶어 제공한다. 초보자에게는 편리할 수 있지만, 시스템 환경을 복잡하게 만들 수 있고 용량이 크다는 단점이 있다. 이 책에서는 공식 파이썬 설치를 기준으로 설명한다.\n파이썬 환경 관리: uv\n과거에는 pip로 패키지를 설치하고 venv로 가상 환경을 만드는 등 여러 도구를 조합해야 했지만, 최근에는 uv라는 차세대 통합 도구가 등장해 파이썬 개발 환경 관리가 훨씬 빠르고 간편해졌다. uv는 러스트(Rust)로 작성되어 기존 도구보다 수십 배에서 수백 배 빠른 속도를 자랑한다.\nuv 설치: 터미널에서 운영체제에 맞는 명령어를 실행해 uv를 설치한다. 맥OS/리눅스에서는 curl -LsSf https://astral.sh/uv/install.sh | sh를, 윈도우 파워셸(PowerShell)에서는 powershell -c \"irm https://astral.sh/uv/install.ps1 | iex\"를 실행한다.\n가상 환경 생성: 프로젝트 폴더로 이동한 후 터미널에서 uv venv 명령어를 실행하면 .venv라는 폴더에 가상 환경이 생성된다.\n가상 환경 활성화: 윈도우에서는 .\\.venv\\Scripts\\activate를, 맥OS/리눅스에서는 source .venv/bin/activate를 실행한다. 활성화되면 터미널 프롬프트 앞에 (.venv)와 같은 표시가 나타난다.\n패키지 설치: 가상 환경이 활성화된 상태에서 uv pip install 명령어로 패키지를 매우 빠르게 설치할 수 있다. 예를 들어 uv pip install pandas scikit-learn 명령으로 pandas와 scikit-learn을 설치하거나, uv pip install -r requirements.txt 명령으로 requirements.txt 파일로부터 패키지를 설치한다.\n작업이 끝나면 터미널에서 deactivate 명령어를 실행해 가상 환경을 비활성화한다.\n설치 확인: 다음 명령어로 uv가 정상 설치되었는지 확인한다:\n$ uv --version\nuv 0.1.18\n\n$ uv pip list\nPackage    Version\n---------- -------\npip        24.0\nsetuptools 69.0.3",
    "crumbs": [
      "**5부** 통합 개발 환경",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>개발 환경 구축</span>"
    ]
  },
  {
    "objectID": "ide_setup.html#sec-setup-ide",
    "href": "ide_setup.html#sec-setup-ide",
    "title": "4  개발 환경 구축",
    "section": "\n4.6 통합 개발 환경 설치",
    "text": "4.6 통합 개발 환경 설치\n\n4.6.1 Positron IDE 설치\nPositron은 R과 파이썬을 모두 지원하는 차세대 데이터 과학 IDE다. VS Code 기반의 현대적인 인터페이스와 RStudio의 강력한 데이터 과학 기능을 결합하여 두 언어를 함께 사용하는 데이터 과학자에게 최적화된 환경을 제공한다.\nPositron 다운로드에서 운영체제(윈도우, 맥OS, 리눅스)에 맞는 설치 프로그램을 다운로드한다. Positron은 현재 베타 버전이므로 최신 정보를 확인하는 것이 중요하다. 다운로드한 파일을 실행하고 안내에 따라 설치를 진행한다. 대부분 경우 기본 설정을 따르는 것이 좋다.\nPositron은 R과 파이썬 인터프리터를 함께 사용한다. 설치 후 Positron을 실행하여 Tools → Global Options 또는 Preferences에서 R 및 파이썬 인터프리터 경로가 올바르게 설정되었는지 확인한다. 이를 통해 Positron이 시스템에 설치된 R 및 파이썬 환경을 정확히 인식하고 활용할 수 있다.",
    "crumbs": [
      "**5부** 통합 개발 환경",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>개발 환경 구축</span>"
    ]
  },
  {
    "objectID": "ide_setup.html#sec-setup-quarto",
    "href": "ide_setup.html#sec-setup-quarto",
    "title": "4  개발 환경 구축",
    "section": "\n4.7 문학적 프로그래밍",
    "text": "4.7 문학적 프로그래밍\nPositron IDE는 쿼토를 잘 지원하지만, 쿼토의 모든 기능을 활용해 다양한 포맷(특히 PDF)으로 문서를 렌더링하려면 몇 가지 추가 도구가 필요할 수 있다.\n판독(Pandoc): 쿼토는 문서 변환의 핵심 엔진으로 판독을 사용한다. 대부분 경우 쿼토 설치 시 판독이 함께 번들되어 제공되므로 별도로 설치할 필요는 없다. 터미널에서 pandoc --version 명령어를 실행해 설치 여부와 버전을 확인할 수 있다.\n\\(\\LaTeX\\) 배포판 (PDF 출력을 위해 필수): 쿼토로 PDF 문서를 생성하려면 \\(\\LaTeX\\) 배포판이 시스템에 설치되어 있어야 한다. 쿼토는 자동으로 TinyTEX을 설치할 수 있도록 지원하며, 이는 가장 권장되는 방법이다. R 콘솔 또는 Positron의 터미널에서 다음 명령어를 실행해 TinyTEX을 설치한다:\ninstall.packages(\"tinytex\")\ntinytex::install_tinytex()\nTinyTEX 대신 MiKTEX(윈도우)나 TEX Live(리눅스/맥OS) 같은 다른 \\(\\LaTeX\\) 배포판을 설치할 수도 있다. 하지만 TinyTEX이 가장 가볍고 쿼토와 통합이 용이하다.\n쿼토 CLI 설치 확인: Positron 자체에 쿼토 기능이 통합되어 있더라도 터미널에서 쿼토 명령어를 직접 사용하려면 쿼토 CLI가 설치되어 있어야 한다. 쿼토 공식 웹사이트에서 설치하거나 quarto install 명령어를 통해 설치할 수 있다. Positron이 쿼토를 번들하는 경우도 많으므로 먼저 quarto --version으로 확인하는 것이 좋다.\n설정 확인: 쿼토 관련 설정이 모두 완료되면 터미널에서 quarto check 명령어를 실행해 필요한 도구들이 올바르게 설정되었는지 진단할 수 있다.",
    "crumbs": [
      "**5부** 통합 개발 환경",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>개발 환경 구축</span>"
    ]
  },
  {
    "objectID": "ide_setup.html#sec-setup-fonts",
    "href": "ide_setup.html#sec-setup-fonts",
    "title": "4  개발 환경 구축",
    "section": "\n4.8 개발 글꼴",
    "text": "4.8 개발 글꼴\n개발자가 마주하는 폰트 환경은 세 가지로 나뉜다. 코드 편집기와 터미널에서는 고정폭(monospace) 폰트가 필수다. 웹이나 앱의 UI를 디자인할 때는 시스템과 조화를 이루는 가변폭 산세리프 폰트를 사용한다. 기술 문서나 블로그처럼 장문을 다룰 때는 장시간 읽기에 적합한 폰트가 필요하다.\n\n\n\n\n\n그림 4.6: 개발자 폰트 생태계\n\n\n그림 4.6 은 개발자 폰트 생태계를 용도별로 정리한다. 코딩 환경에서는 JetBrains Mono, Fira Code, D2코딩이 대표적이다. 특히 D2코딩은 한글 가독성이 뛰어나 한국 개발자에게 필수로 꼽힌다. 웹과 앱 UI에서는 프리텐다드가 한국 웹 표준으로 자리잡았고, 글로벌 환경에서는 Inter가 널리 쓰인다. 구글의 Noto Sans CJK는 “No more Tofu”라는 슬로건 아래 800개 이상의 언어를 지원하며, 폰트 깨짐 없는 다국어 환경을 제공한다. 문서 작성에서는 Noto 패밀리가 Sans, Serif, Mono 전방위로 활약하며, IBM Plex Sans나 마루부리 같은 폰트도 기술 블로그와 출판물에 자주 등장한다.\nNoto 프로젝트는 구글이 시작한 범세계적 폰트 이니셔티브다. “Tofu”는 폰트가 없어서 나타나는 □ 문자를 의미하는데, Noto는 이 문제를 해결하고자 탄생했다. 한글, 중국어, 일본어를 포함한 CJK(Chinese, Japanese, Korean) 언어부터 아랍어, 히브리어, 태국어까지 모든 문자를 하나의 통일된 디자인으로 제공한다. 개발자가 다국어 환경을 구축할 때 Noto 패밀리를 사용하면 언어별로 폰트를 따로 관리할 필요 없이 일관된 타이포그래피를 유지할 수 있다.\n\n4.8.1 D2코딩 폰트 설치\n개발 환경에서 폰트를 사용하려면 두 단계를 거친다. 먼저 폰트를 운영체제에 설치하고, 그 다음 IDE 설정에서 해당 폰트를 지정한다. D2코딩은 한글과 영문이 조화롭게 어우러지도록 설계된 모노스페이스 폰트로, 한국 개발자에게 가장 많이 쓰인다.\nD2코딩 GitHub 릴리즈 페이지에서 최신 zip 파일을 다운로드한 뒤 압축을 풀면 .ttf 파일이 나타난다. 이 파일을 더블 클릭하면 윈도우에서는 ‘설치’ 버튼이, 맥OS에서는 ‘서체 설치’ 버튼이 나타난다. 버튼을 클릭하면 시스템 전체에서 D2코딩 폰트를 사용할 수 있게 된다.\n시스템 설치가 끝나면 IDE에서 이 폰트를 지정한다. Positron이나 VS Code에서 Cmd/Ctrl + ,로 설정을 열고 font family를 검색한다. ‘Editor: Font Family’ 항목의 맨 앞에 'D2Coding',을 추가하면 코드 편집기가 D2코딩을 최우선으로 사용한다. 예를 들어 다음과 같은 형태가 된다:\n'D2Coding', \"Apple SD Gothic Neo\", \"Malgun Gothic\", monospace\n폰트 목록의 맨 앞에 배치한 이유는 간단하다. IDE는 목록 순서대로 폰트를 찾아 사용하므로, D2코딩이 설치되어 있으면 이 폰트로 표시하고, 없으면 다음 폰트로 넘어간다. 설정을 저장하면 편집기 화면이 즉시 D2코딩으로 바뀐다.\n\n4.8.2 프리텐다드 가변 글꼴\n프리텐다드는 D2코딩과 달리 웹 환경을 위해 설계된 가변 글꼴이다. 가변 폰트(Variable Font)는 하나의 파일에 여러 weight(두께)를 담는 기술로, 프리텐다드는 Thin(100)부터 Black(900)까지 9단계를 지원한다. 한글, 영문, 일본어를 모두 포괄하며, 윈도우와 맥OS, 리눅스에서 일관된 렌더링을 보장한다. 특히 쿼토로 생성한 HTML 문서나 GitHub Pages, 기술 블로그처럼 웹에 게시되는 콘텐츠에서 시스템 폰트의 한계를 넘어서는 가독성을 제공한다.\n프리텐다드는 사용 목적에 따라 두 가지 방식으로 설치한다. 프리텐다드 GitHub 릴리즈에서 zip 파일을 다운로드하면 여러 형식의 폰트 파일이 들어 있다. IDE나 데스크톱 애플리케이션에서 사용하려면 public/static 폴더의 OTF나 TTF 파일을 시스템에 설치한다. D2코딩과 같은 방식이다.\n웹 페이지에 직접 삽입하려면 web/variable 폴더의 WOFF2 파일을 사용한다. 쿼토 프로젝트의 _quarto.yml이나 CSS 파일에서 @font-face로 선언하면 방문자의 시스템에 폰트가 없어도 웹 페이지에서 프리텐다드를 표시할 수 있다:\n@font-face {\n  font-family: 'Pretendard';\n  src: url('fonts/PretendardVariable.woff2') format('woff2-variations');\n  font-weight: 100 900;\n}\n\nbody {\n  font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, sans-serif;\n}\n웹 폰트로 사용하면 모든 플랫폼의 방문자에게 일관된 타이포그래피를 제공할 수 있다. 시스템 폰트는 사용자의 OS에 따라 달라지지만, 웹 폰트는 제작자가 의도한 대로 정확히 표시된다.",
    "crumbs": [
      "**5부** 통합 개발 환경",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>개발 환경 구축</span>"
    ]
  },
  {
    "objectID": "ide_setup.html#sec-setup-verify",
    "href": "ide_setup.html#sec-setup-verify",
    "title": "4  개발 환경 구축",
    "section": "\n4.9 개발 환경 검증",
    "text": "4.9 개발 환경 검증\n지금까지 포지트론 IDE부터 시작해 R과 파이썬, Git과 도커, 워크플로우 자동화 도구(make, targets, 스네이크메이크, Task), 쿼토 출판 시스템, 개발 글꼴(D2코딩, 프리텐다드)까지 현대 데이터 과학 환경의 핵심 요소들을 설치했다. 각 도구는 독립적으로 작동하지만, 함께 사용할 때 시너지를 발휘한다. 포지트론에서 R 코드로 데이터를 분석하고, targets로 워크플로우를 자동화하며, 쿼토로 결과를 문서화하고, Git으로 버전을 관리하는 통합 환경이 완성된 것이다. 설치가 제대로 되었는지 확인하는 것이 다음 단계다.\n핵심 도구들의 설치 여부를 터미널에서 한번에 확인할 수 있다:\n$ git --version && docker --version && make --version | head -1 && R --version | head -1 && python --version && uv --version\ngit version 2.39.2 (Apple Git-143)\nDocker version 24.0.6, build ed223bc\nGNU Make 3.81\nR version 4.3.0 (2023-04-21) -- \"Already Tomorrow\"\nPython 3.11.5\nuv 0.1.18\n모든 명령어가 버전 정보를 출력하면 기본 환경 구축이 완료된 것이다. 워크플로우 자동화 도구는 필요에 따라 선택적으로 확인한다. R 프로젝트라면 R 콘솔에서 library(targets)를 실행해 targets 패키지가 로드되는지 확인하고, Python 생물정보학 프로젝트라면 snakemake --version으로 스네이크메이크 설치를 점검한다. 범용 빌드 도구인 Task를 설치했다면 task --version으로 확인한다.\n개발 글꼴도 IDE 설정에서 확인한다. 포지트론이나 VS Code의 설정(Cmd/Ctrl + ,)에서 ’Font Family’를 검색하면 D2코딩이나 프리텐다드가 목록 맨 앞에 있는지 확인할 수 있다. 코드 편집기에서 한글과 영문이 조화롭게 표시되면 글꼴 설정이 올바른 것이다.\n모든 검증이 완료되면 포지트론을 실행하고 R과 파이썬 인터프리터 경로를 설정해 첫 데이터 과학 프로젝트를 시작할 준비가 된다.",
    "crumbs": [
      "**5부** 통합 개발 환경",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>개발 환경 구축</span>"
    ]
  }
]