---
execute:
  eval: false
---

# 의도 명세하기 {#sec-spec}

프로그래밍의 본질은 "컴퓨터에게 원하는 일을 시키는 것"이다. 전통적으로 이 과정은 프로그래밍 언어의 구문(syntax)을 배우고, 그 구문으로 코드를 직접 작성하는 방식으로 진행되었다. 그러나 AI 시대에는 근본적인 전환이 일어났다. 이제 코드 작성은 AI가 더 빠르고 정확하게 수행한다. 그렇다면 인간의 역할은 무엇인가?

**의도를 명확하게 표현하는 것**이다.

## AI 시대 프로그래밍 패러다임 {#sec-spec-paradigm}

\index{AI 시대 프로그래밍}기존 프로그래밍 교육은 구문 암기 → 예제 따라하기 → 연습 문제 풀기 → 디버깅의 순서로 진행되었다. 이 방식의 문제점은 "왜 이렇게 짜는가"보다 "어떻게 쓰는가"에 집중한다는 것이다.

![전통적 학습과 AI 시대 학습의 비교](images/traditional-vs-ai-learning.svg){#fig-traditional-vs-ai}

AI 시대 프로그래밍은 순서가 바뀐다:

1. **의도 명세** - "무엇을 원하는가"를 명확히 정의
2. **AI 코드 생성** - AI에게 구현을 위임
3. **코드 이해** - 생성된 코드의 동작 원리 파악
4. **검증과 개선** - 의도대로 동작하는지 확인

이 패러다임에서 인간의 핵심 역량은 **의도를 명확하게 표현하는 능력**이다.

## 테스트는 명세서다 {#sec-spec-test-is-spec}

\index{테스트 주도 개발}\index{TDD}의도를 표현하는 가장 효과적인 방법은 **테스트 코드**를 작성하는 것이다. 테스트는 단순히 코드의 정확성을 검증하는 도구가 아니다. AI 시대에 테스트는 "내가 원하는 것"을 AI가 이해할 수 있는 형식으로 표현한 **명세서(Specification)**가 된다.

![테스트 = AI에게 의도를 전달하는 명세서](images/test-as-specification.svg){#fig-test-as-spec}

### 명세서가 담아야 할 정보 {#sec-spec-what-to-include}

좋은 테스트(명세서)는 다음 정보를 담아야 한다:

- **함수/기능의 이름**: 무엇을 하는 기능인가
- **입력(Input)**: 어떤 데이터를 받는가
- **출력(Output)**: 어떤 결과를 반환하는가
- **경계 조건**: 특수한 상황에서 어떻게 동작해야 하는가

## 관통 예제: 간단한 계산기 {#sec-spec-calculator}

\index{계산기 예제}이 책 전체를 관통하는 예제로 **간단한 계산기**를 만들어 보자. 계산기는 단순해 보이지만, 프로그래밍의 핵심 개념을 모두 담고 있다.

### 덧셈 기능의 의도 명세 {#sec-spec-add-function}

"두 숫자를 더하는 기능이 필요해."

이 의도를 테스트 코드로 표현하면:

```python
#| eval: false
def test_add():
    """덧셈 기능에 대한 명세서"""

    # 기본 덧셈
    assert add(2, 3) == 5
    assert add(0, 0) == 0
    assert add(100, 200) == 300

    # 음수 처리
    assert add(-1, 1) == 0
    assert add(-2, -3) == -5

    # 소수점
    assert add(1.5, 2.5) == 4.0
```

이 테스트 코드가 담고 있는 명세:

| 항목 | 내용 |
|---|---|
| 함수 이름 | `add` |
| 입력 | 두 개의 숫자 (정수, 음수, 소수 모두 가능) |
| 출력 | 두 수의 합 |
| 특이사항 | 음수와 소수점도 올바르게 처리해야 함 |

: 테스트 코드에서 추출한 명세서 {#tbl-add-spec}

### 왜 테스트가 먼저인가? {#sec-spec-test-first}

\index{Red-Green-Refactor}전통적 프로그래밍에서는 코드를 먼저 작성하고 테스트는 나중에(혹은 아예 안) 작성했다. AI 시대에는 순서가 바뀐다:

```
Red:     실패하는 테스트 작성 (인간) ← 핵심 역량
Green:   테스트 통과하는 코드 생성 (AI)
Refactor: 코드 리뷰 및 개선 (인간 + AI 협업)
```

![AI 시대 TDD 워크플로우](images/ai-tdd-workflow.svg){#fig-ai-tdd}

테스트를 먼저 작성하면:

1. **의도가 명확해진다** - "무엇을 원하는가"를 구체적으로 생각하게 됨
2. **AI 소통이 정확해진다** - 모호한 자연어 대신 정확한 코드로 의도 전달
3. **검증이 자동화된다** - AI가 생성한 코드가 맞는지 즉시 확인 가능

## 테스트 작성의 기초 {#sec-spec-basics}

### assert 문 이해하기 {#sec-spec-assert}

\index{assert}`assert`는 "이것이 참이어야 한다"는 선언이다:

```python
#| eval: false
# 기본 형태
assert 1 + 1 == 2          # 통과: 참이므로
# assert 1 + 1 == 3        # 실패: AssertionError 발생
```

```python
#| eval: false
# 변수와 함께
result = 10 * 5
assert result == 50        # result가 50인지 확인
```

### 좋은 테스트의 특징 {#sec-spec-good-test}

**1. 하나의 테스트는 하나의 동작을 검증한다**

```python
#| eval: false
# 좋은 예: 각각 분리
def test_add_positive_numbers():
    assert add(2, 3) == 5

def test_add_negative_numbers():
    assert add(-2, -3) == -5
```

**2. 테스트 이름이 의도를 설명한다**

```python
#| eval: false
# 나쁜 예
def test1():
    assert add(2, 3) == 5

# 좋은 예
def test_add_returns_sum_of_two_positive_integers():
    assert add(2, 3) == 5
```

**3. 경계 조건을 포함한다**

```python
#| eval: false
def test_add_edge_cases():
    assert add(0, 0) == 0              # 영(零)
    assert add(-1, 1) == 0             # 상쇄
    assert add(999999, 1) == 1000000   # 큰 수
```

## 실습: 뺄셈 기능 명세하기 {#sec-spec-practice}

계산기에 뺄셈 기능을 추가해보자. 먼저 테스트(명세서)를 작성한다:

```python
#| eval: false
def test_subtract():
    """뺄셈 기능에 대한 명세서"""

    # 기본 뺄셈
    assert subtract(5, 3) == 2
    assert subtract(10, 10) == 0

    # 음수 결과
    assert subtract(3, 5) == -2

    # 음수 입력
    assert subtract(-3, -5) == 2    # -3 - (-5) = 2
    assert subtract(-3, 5) == -8    # -3 - 5 = -8
```

이 테스트가 담고 있는 명세를 정리해보면:

- 함수 이름: `subtract`
- 입력: 두 개의 숫자 (첫 번째에서 두 번째를 뺌)
- 출력: 차이 값
- 특이사항: 음수 입력과 음수 결과를 올바르게 처리

## 핵심 정리 {#sec-spec-summary}

:::{.callout-tip}
## AI 시대 프로그래밍의 핵심

1. **테스트 = 명세서**: 테스트는 "내가 원하는 것"을 정확히 표현한 문서다
2. **의도 먼저**: 코드 작성 전에 의도를 명확히 정의한다
3. **AI는 실행자**: 명세(테스트)를 주면 AI가 코드를 생성한다
4. **인간은 설계자**: 무엇을 만들지 결정하고, 결과를 검증하는 것이 인간의 역할
:::

다음 장에서는 이렇게 작성한 테스트를 AI에게 전달하여 실제 코드를 생성받는 방법을 알아본다.
